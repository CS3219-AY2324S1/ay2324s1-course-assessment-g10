{
    "c++17": {
        "repr": "C++ 17",
        "default": "#include <iostream>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cout << \"Hello world!\";\n}\n",
        "template": [
            [
                "AVL Tree",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch2/nonlineards/AVL.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Every vertex in this BST is a C Struct (to expose all its members publicly)\nstruct BSTVertex {\n  // all these attributes remain public to slightly simplify the code although this may not be the best practice\n  BSTVertex* parent;\n  BSTVertex* left;\n  BSTVertex* right;\n  int key;\n  int height; // will be used in AVL lecture\n};\n\n// This is just a sample implementation\n// There are other ways to implement BST concepts...\nclass BST {\nprotected:\n  BSTVertex *root;\n\n  BSTVertex* insert(BSTVertex* T, int v) {\n    if (T == NULL) {                             // insertion point is found\n      T = new BSTVertex;\n      T->key = v;\n      T->parent = T->left = T->right = NULL;\n      T->height = 0;                             // used in AVL lecture\n    }\n    else if (T->key < v) {                       // search to the right\n      T->right = insert(T->right, v);\n      T->right->parent = T;\n    }\n    else {                                       // search to the left\n      T->left = insert(T->left, v);\n      T->left->parent = T;\n    }\n    return T;                                    // return the updated BST\n  }\n\n  void inorder(BSTVertex* T) {\n    if (T == NULL) return;\n    inorder(T->left);                            // recursively go to the left\n    printf(\" %d\", T->key);                       // visit this BST node\n    inorder(T->right);                           // recursively go to the right\n  }\n\n  void preorder(BSTVertex* T) {\n    if (T == NULL) return;\n    printf(\" %d\", T->key);                       // visit this BST node\n    preorder(T->left);                           // recursively go to the left\n    preorder(T->right);                          // recursively go to the right\n  }\n\n  int findMin(BSTVertex* T) {\n         if (T == NULL)       return -1;         // BST is empty, no minimum\n    else if (T->left == NULL) return T->key;     // this is the min\n    else                      return findMin(T->left); // go to the left\n  }\n\n  int findMax(BSTVertex* T) {\n         if (T == NULL)        return -1;        // BST is empty, no maximum\n    else if (T->right == NULL) return T->key;    // this is the max\n    else                       return findMax(T->right); // go to the right\n  }\n\n  BSTVertex* search(BSTVertex* T, int v) {\n         if (T == NULL)   return T;              // not found\n    else if (T->key == v) return T;              // found\n    else if (T->key < v)  return search(T->right, v); // search to the right\n    else                  return search(T->left, v); // search to the left\n  }\n\n  int successor(BSTVertex* T) {\n    if (T->right != NULL)                        // we have right subtree\n      return findMin(T->right);                  // this is the successor\n    else {\n      BSTVertex* par = T->parent;\n      BSTVertex* cur = T;\n      // if par(ent) is not root and cur(rent) is its right children\n      while ((par != NULL) && (cur == par->right)) {\n        cur = par;                               // continue moving up\n        par = cur->parent;\n      }\n      return par == NULL ? -1 : par->key;        // this is the successor of T\n    }\n  }\n\n  int predecessor(BSTVertex* T) {\n    if (T->left != NULL)                         // we have left subtree\n      return findMax(T->left);                   // this is the predecessor\n    else {\n      BSTVertex* par = T->parent;\n      BSTVertex* cur = T;\n      // if par(ent) is not root and cur(rent) is its left children\n      while ((par != NULL) && (cur == par->left)) { \n        cur = par;                               // continue moving up\n        par = cur->parent;\n      }\n      return par == NULL ? -1 : par->key;        // this is the successor of T\n    }\n  }\n\n  BSTVertex* remove(BSTVertex* T, int v) {\n    if (T == NULL)  return T;                    // cannot find the item\n\n    if (T->key == v) {                           // the node to be deleted\n      if (T->left == NULL && T->right == NULL)   // this is a leaf\n        T = NULL;                                // simply erase this node\n      else if (T->left == NULL && T->right != NULL) { // only one child at right\n        T->right->parent = T->parent;            // ma, take care of my child\n        T = T->right;                            // bypass T\n      }\n      else if (T->left != NULL && T->right == NULL) { // only one child at left\n        T->left->parent = T->parent;             // ma, take care of my child\n        T = T->left;                             // bypass T\n      }\n      else { // has two children, find successor to avoid quarrel\n        int successorV = successor(v);           // predecessor is also OK btw\n        T->key = successorV;                     // replace with successorV\n        T->right = remove(T->right, successorV); // delete the old successorV\n      }\n    }\n    else if (T->key < v)                         // search to the right\n      T->right = remove(T->right, v);\n    else                                         // search to the left\n      T->left = remove(T->left, v);\n    return T;                                    // return the updated BST\n  }\n\n  // will be used in AVL lecture\n  int getHeight(BSTVertex* T) {\n    if (T == NULL) return -1;\n    else return max(getHeight(T->left), getHeight(T->right)) + 1;\n  }\n\npublic:\n  BST() { root = NULL; }\n\n  void insert(int v) { root = insert(root, v); }\n\n  void inorder() { \n    inorder(root);\n    printf(\"\\n\");\n  }\n\n  void preorder() { \n    preorder(root);\n    printf(\"\\n\");\n  }\n\n  int findMin() { return findMin(root); }\n\n  int findMax() { return findMax(root); }\n\n  int search(int v) {\n    BSTVertex* res = search(root, v);\n    return res == NULL ? -1 : res->key;\n  }\n\n  int successor(int v) { \n    BSTVertex* vPos = search(root, v);\n    return vPos == NULL ? -1 : successor(vPos);\n  }\n\n  int predecessor(int v) { \n    BSTVertex* vPos = search(root, v);\n    return vPos == NULL ? -1 : predecessor(vPos);\n  }\n\n  void remove(int v) { root = remove(root, v); }\n\n  // will be used in AVL lecture\n  int getHeight() { return getHeight(root); }\n};\n\nclass AVL : public BST { // another example of C++ inheritance\nprivate:\n  int h(BSTVertex* T) { return T == NULL ? -1 : T->height; }\n\n  BSTVertex* rotateLeft(BSTVertex* T) {\n    // T must have a right child\n\n    BSTVertex* w = T->right;\n    w->parent = T->parent;\n    T->parent = w;\n    T->right = w->left;\n    if (w->left != NULL) w->left->parent = T;\n    w->left = T;\n\n    T->height = max(h(T->left), h(T->right)) + 1;\n    w->height = max(h(w->left), h(w->right)) + 1;\n\n    return w;\n  }\n\n  BSTVertex* rotateRight(BSTVertex* T) {\n    // T must have a left child\n\n    BSTVertex* w = T->left;\n    w->parent = T->parent;\n    T->parent = w;\n    T->left = w->right;\n    if (w->right != NULL) w->right->parent = T;\n    w->right = T;\n\n    T->height = max(h(T->left), h(T->right)) + 1;\n    w->height = max(h(w->left), h(w->right)) + 1;\n\n    return w;\n  }\n\n  BSTVertex* insert(BSTVertex* T, int v) {       // override insert in BST class\n    if (T == NULL) {                             // insertion point is found\n      T = new BSTVertex;\n      T->key = v;\n      T->parent = T->left = T->right = NULL;\n      T->height = 0; // will be used in AVL lecture\n    }\n    else if (T->key < v) {                       // search to the right\n      T->right = insert(T->right, v);\n      T->right->parent = T;\n    }\n    else {                                       // search to the left\n      T->left = insert(T->left, v);\n      T->left->parent = T;\n    }\n\n    int balance = h(T->left) - h(T->right);\n    if (balance == 2) { // left heavy\n      int balance2 = h(T->left->left) - h(T->left->right);\n      if (balance2 == 1) {\n        T = rotateRight(T);\n      }\n      else { // -1\n        T->left = rotateLeft(T->left);\n        T = rotateRight(T);\n      }\n    }\n    else if (balance == -2) { // right heavy\n      int balance2 = h(T->right->left) - h(T->right->right);\n      if (balance2 == -1)\n        T = rotateLeft(T);\n      else { // 1\n        T->right = rotateRight(T->right);\n        T = rotateLeft(T);\n      }\n    }\n\n    T->height = max(h(T->left), h(T->right)) + 1;\n    return T;                                    // return the updated AVL\n  }\n\n  BSTVertex* remove(BSTVertex* T, int v) {\n    if (T == NULL)  return T;                    // cannot find the item\n\n    if (T->key == v) {                           // the node to be deleted\n      if (T->left == NULL && T->right == NULL)   // this is a leaf\n        T = NULL;                                // simply erase this node\n      else if (T->left == NULL && T->right != NULL) { // only one child at right\n        T->right->parent = T->parent;\n        T = T->right;                            // bypass T\n      }\n      else if (T->left != NULL && T->right == NULL) { // only one child at left\n        T->left->parent = T->parent;\n        T = T->left;                             // bypass T\n      }\n      else {                                     // find successor\n        int successorV = successor(v);\n        T->key = successorV;                     // replace with successorV\n        T->right = remove(T->right, successorV); // delete the old successorV\n      }\n    }\n    else if (T->key < v)                         // search to the right\n      T->right = remove(T->right, v);\n    else                                         // search to the left\n      T->left = remove(T->left, v);\n\n    if (T != NULL) {               // similar as insertion code except this line\n      int balance = h(T->left) - h(T->right);\n      if (balance == 2) { // left heavy\n        int balance2 = h(T->left->left) - h(T->left->right);\n        if (balance2 == 1) {\n          T = rotateRight(T);\n        }\n        else { // -1\n          T->left = rotateLeft(T->left);\n          T = rotateRight(T);\n        }\n      }\n      else if (balance == -2) { // right heavy\n        int balance2 = h(T->right->left) - h(T->right->right);\n        if (balance2 == -1)\n          T = rotateLeft(T);\n        else { // 1\n          T->right = rotateRight(T->right);\n          T = rotateLeft(T);\n        }\n      }\n\n      T->height = max(h(T->left), h(T->right)) + 1;\n    }\n\n    return T;                                    // return the updated BST\n  }\n\npublic:\n  AVL() { root = NULL; }\n\n  void insert(int v) { root = insert(root, v); }\n\n  void remove(int v) { root = remove(root, v); }\n};\n\nint main() {\n  // let's contrast and compare\n  BST* T = new BST();                            // an empty BST\n  AVL* A = new AVL();                            // an empty AVL\n\n  int n = 12;\n  int arr[] = {15, 32, 100, 6, 23, 4, 7, 71, 5, 50, 3, 1};\n  for (int i = 0; i < n; i++) {\n    T->insert(arr[i]);\n    A->insert(arr[i]);\n  }\n\n  // Example of C++ polymorphism: method getHeight() returns different value\n  printf(\"%d\\n\", T->getHeight());                // 4, taller tree\n  printf(\"%d\\n\", A->getHeight());                // 3, shorter tree\n\n  // Another C++ polymorphism: method inorder() returns similar value\n  T->inorder(); // The BST: 1 3 4 5 6 7 15 23 32 50 71 100\n  A->inorder(); // The AVL: 1 3 4 5 6 7 15 23 32 50 71 100\n\n  printf(\"---\\n\");\n  printf(\"%d\\n\", A->search(71));                 // found, 71\n  printf(\"%d\\n\", A->search(7));                  // found, 7\n  printf(\"%d\\n\", A->search(22));                 // not found, -1\n\n  printf(\"%d\\n\", A->findMin());                  // 1\n  printf(\"%d\\n\", A->findMax());                  // 100\n\n  sort(arr, arr+n);\n  printf(\"---\\n\");\n  for (int i = 0; i < n; i++)\n    printf(\"%d %d %d\\n\", A->predecessor(arr[i]), arr[i], A->successor(arr[i]));\n\n  // deletion demo\n  printf(\"---\\n\");\n  printf(\"Current BST/AVL:\");\n  A->inorder();\n\n  int deletionorder[] = {23, 100, 32, 71, 50, 7, 5, 1, 3, 6, 15, 4};\n  for (int i = 0; i < n; ++i) {\n    printf(\"Deleting: %d\\n\", deletionorder[i]);\n\n    A->remove(deletionorder[i]);\n    printf(\"AVL, height: %d, inorder traversal:\", A->getHeight());\n    A->inorder();\n\n    T->remove(deletionorder[i]);\n    printf(\"BST, height: %d, inorder traversal:\", T->getHeight()); // equal or taller than A->getHeight()\n    T->inorder(); // should be the same as A.inorder()\n  }\n  return 0;\n}\n"
            ],
            [
                "Quick Select",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch2/nonlineards/QuickSelect.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint Partition(int A[], int l, int r) {\n  int p = A[l];                                  // p is the pivot\n  int m = l;                                     // S1 and S2 are empty\n  for (int k = l+1; k <= r; ++k) {               // explore unknown region\n    if (A[k] < p) {                              // case 2\n      ++m;\n      swap(A[k], A[m]);\n    } // notice that we do nothing in case 1: a[k] >= p\n  }\n  swap(A[l], A[m]);                              // swap pivot with a[m]\n  return m;                                      // return pivot index\n}\n\nint RandPartition(int A[], int l, int r) {\n  int p = l + rand() % (r-l+1);                  // select a random pivot\n  swap(A[l], A[p]);                              // swap A[p] with A[l]\n  return Partition(A, l, r);\n}\n\nint QuickSelect(int A[], int l, int r, int k) {  // expected O(n)\n  if (l == r) return A[l];\n  int q = RandPartition(A, l, r);                // O(n)\n  if (q+1 == k)\n    return A[q];\n  else if (q+1 > k)\n    return QuickSelect(A, l, q-1, k);\n  else\n    return QuickSelect(A, q+1, r, k);\n}\n\nint main() {\n  int A[] = { 2, 8, 7, 1, 5, 4, 6, 3 };          // permutation of [1..8]\n\n  printf(\"%d\\n\", QuickSelect(A, 0, 7, 8));       // the output must be 8\n  printf(\"%d\\n\", QuickSelect(A, 0, 7, 7));       // the output must be 7\n  printf(\"%d\\n\", QuickSelect(A, 0, 7, 6));       // the output must be 6\n  printf(\"%d\\n\", QuickSelect(A, 0, 7, 5));       // the output must be 5\n  printf(\"%d\\n\", QuickSelect(A, 0, 7, 4));       // the output must be 4\n  printf(\"%d\\n\", QuickSelect(A, 0, 7, 3));       // the output must be 3\n  printf(\"%d\\n\", QuickSelect(A, 0, 7, 2));       // the output must be 2\n  printf(\"%d\\n\", QuickSelect(A, 0, 7, 1));       // the output must be 1\n\n  // try experimenting with the content of array A to see the behavior of \"QuickSelect\"\n  return 0;\n}\n"
            ],
            [
                "Fenwick Tree",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch2/ourown/fenwicktree_ds.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define LSOne(S) ((S) & -(S))                    // the key operation\n\ntypedef long long ll;                            // for extra flexibility\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\n\nclass FenwickTree {                              // index 0 is not used\nprivate:\n  vll ft;                                        // internal FT is an array\npublic:\n  FenwickTree(int m) { ft.assign(m+1, 0); }      // create an empty FT\n\n  void build(const vll &f) {\n    int m = (int)f.size()-1;                     // note f[0] is always 0\n    ft.assign(m+1, 0);\n    for (int i = 1; i <= m; ++i) {               // O(m)\n      ft[i] += f[i];                             // add this value\n      if (i+LSOne(i) <= m)                       // i has parent\n        ft[i+LSOne(i)] += ft[i];                 // add to that parent\n    }\n  }\n\n  FenwickTree(const vll &f) { build(f); }        // create FT based on f\n\n  FenwickTree(int m, const vi &s) {              // create FT based on s\n    vll f(m+1, 0);\n    for (int i = 0; i < (int)s.size(); ++i)      // do the conversion first\n      ++f[s[i]];                                 // in O(n)\n    build(f);                                    // in O(m)\n  }\n\n  ll rsq(int j) {                                // returns RSQ(1, j)\n    ll sum = 0;\n    for (; j; j -= LSOne(j))\n      sum += ft[j];\n    return sum;\n  }\n\n  ll rsq(int i, int j) { return rsq(j) - rsq(i-1); } // inc/exclusion\n\n  // updates value of the i-th element by v (v can be +ve/inc or -ve/dec)\n  void update(int i, ll v) {\n    for (; i < (int)ft.size(); i += LSOne(i))\n      ft[i] += v;\n  }\n\n  int select(ll k) {                             // O(log m)\n    int p = 1;\n    while (p*2 < (int)ft.size()) p *= 2;\n    int i = 0;\n    while (p) {\n      if (k > ft[i+p]) {\n        k -= ft[i+p];\n        i += p;\n      }\n      p /= 2;\n    }\n    return i+1;\n  }\n};\n\nclass RUPQ {                                     // RUPQ variant\nprivate:\n  FenwickTree ft;                                // internally use PURQ FT\npublic:\n  RUPQ(int m) : ft(FenwickTree(m)) {}\n  void range_update(int ui, int uj, ll v) {\n    ft.update(ui, v);                            // [ui, ui+1, .., m] +v\n    ft.update(uj+1, -v);                         // [uj+1, uj+2, .., m] -v\n  }                                              // [ui, ui+1, .., uj] +v\n  ll point_query(int i) { return ft.rsq(i); }    // rsq(i) is sufficient\n};\n\nclass RURQ  {                                    // RURQ variant\nprivate:                                         // needs two helper FTs\n  RUPQ rupq;                                     // one RUPQ and\n  FenwickTree purq;                              // one PURQ\npublic:\n  RURQ(int m) : rupq(RUPQ(m)), purq(FenwickTree(m)) {} // initialization\n  void range_update(int ui, int uj, ll v) {\n    rupq.range_update(ui, uj, v);                // [ui, ui+1, .., uj] +v\n    purq.update(ui, v*(ui-1));                   // -(ui-1)*v before ui\n    purq.update(uj+1, -v*uj);                    // +(uj-ui+1)*v after uj\n  }\n  ll rsq(int j) {\n    return rupq.point_query(j)*j -               // optimistic calculation\n           purq.rsq(j);                          // cancelation factor\n  }\n  ll rsq(int i, int j) { return rsq(j) - rsq(i-1); } // standard\n};\n\nint main() {\n  vll f = {0,0,1,0,1,2,3,2,1,1,0};               // index 0 is always 0\n  FenwickTree ft(f);\n  printf(\"%lld\\n\", ft.rsq(1, 6)); // 7 => ft[6]+ft[4] = 5+2 = 7\n  printf(\"%d\\n\", ft.select(7)); // index 6, rsq(1, 6) == 7, which is >= 7\n  ft.update(5, 1); // update demo\n  printf(\"%lld\\n\", ft.rsq(1, 10)); // now 12\n  printf(\"=====\\n\");\n  RUPQ rupq(10);\n  RURQ rurq(10);\n  rupq.range_update(2, 9, 7); // indices in [2, 3, .., 9] updated by +7\n  rurq.range_update(2, 9, 7); // same as rupq above\n  rupq.range_update(6, 7, 3); // indices 6&7 are further updated by +3 (10)\n  rurq.range_update(6, 7, 3); // same as rupq above\n  // idx = 0 (unused) | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |10\n  // val = -          | 0 | 7 | 7 | 7 | 7 |10 |10 | 7 | 7 | 0\n  for (int i = 1; i <= 10; i++)\n    printf(\"%d -> %lld\\n\", i, rupq.point_query(i));\n  printf(\"RSQ(1, 10) = %lld\\n\", rurq.rsq(1, 10)); // 62\n  printf(\"RSQ(6, 7) = %lld\\n\", rurq.rsq(6, 7)); // 20\n  return 0;\n}\n"
            ],
            [
                "Segment Tree",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch2/ourown/segmenttree_ds.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\n\nclass SegmentTree {                              // OOP style\nprivate:\n  int n;                                         // n = (int)A.size()\n  vi A, st, lazy;                                // the arrays\n\n  int l(int p) { return  p<<1; }                 // go to left child\n  int r(int p) { return (p<<1)+1; }              // go to right child\n\n  int conquer(int a, int b) {\n    if (a == -1) return b;                       // corner case\n    if (b == -1) return a;\n    return min(a, b);                            // RMQ\n  }\n\n  void build(int p, int L, int R) {              // O(n)\n    if (L == R)\n      st[p] = A[L];                              // base case\n    else {\n      int m = (L+R)/2;\n      build(l(p), L  , m);\n      build(r(p), m+1, R);\n      st[p] = conquer(st[l(p)], st[r(p)]);\n    }\n  }\n\n  void propagate(int p, int L, int R) {\n    if (lazy[p] != -1) {                         // has a lazy flag\n      st[p] = lazy[p];                           // [L..R] has same value\n      if (L != R)                                // not a leaf\n        lazy[l(p)] = lazy[r(p)] = lazy[p];       // propagate downwards\n      else                                       // L == R, a single index\n        A[L] = lazy[p];                          // time to update this\n      lazy[p] = -1;                              // erase lazy flag\n    }\n  }\n\n  int RMQ(int p, int L, int R, int i, int j) {   // O(log n)\n    propagate(p, L, R);                          // lazy propagation\n    if (i > j) return -1;                        // infeasible\n    if ((L >= i) && (R <= j)) return st[p];      // found the segment\n    int m = (L+R)/2;\n    return conquer(RMQ(l(p), L  , m, i          , min(m, j)),\n                   RMQ(r(p), m+1, R, max(i, m+1), j        ));\n  }\n\n  void update(int p, int L, int R, int i, int j, int val) { // O(log n)\n    propagate(p, L, R);                          // lazy propagation\n    if (i > j) return;\n    if ((L >= i) && (R <= j)) {                  // found the segment\n      lazy[p] = val;                             // update this\n      propagate(p, L, R);                        // lazy propagation\n    }\n    else {\n      int m = (L+R)/2;\n      update(l(p), L  , m, i          , min(m, j), val);\n      update(r(p), m+1, R, max(i, m+1), j        , val);\n      int lsubtree = (lazy[l(p)] != -1) ? lazy[l(p)] : st[l(p)];\n      int rsubtree = (lazy[r(p)] != -1) ? lazy[r(p)] : st[r(p)];\n      st[p] = (lsubtree <= rsubtree) ? st[l(p)] : st[r(p)];\n    }\n  }\n\npublic:\n  SegmentTree(int sz) : n(sz), st(4*n), lazy(4*n, -1) {}\n\n  SegmentTree(const vi &initialA) : SegmentTree((int)initialA.size()) {\n    A = initialA;\n    build(1, 0, n-1);\n  }\n\n  void update(int i, int j, int val) { update(1, 0, n-1, i, j, val); }\n\n  int RMQ(int i, int j) { return RMQ(1, 0, n-1, i, j); }\n};\n\nint main() {\n  vi A = {18, 17, 13, 19, 15, 11, 20, 99};       // make n a power of 2\n  SegmentTree st(A);\n\n  printf(\"              idx    0, 1, 2, 3, 4, 5, 6, 7\\n\");\n  printf(\"              A is {18,17,13,19,15,11,20,oo}\\n\");\n  printf(\"RMQ(1, 3) = %d\\n\", st.RMQ(1, 3));      // 13\n  printf(\"RMQ(4, 7) = %d\\n\", st.RMQ(4, 7));      // 11\n  printf(\"RMQ(3, 4) = %d\\n\", st.RMQ(3, 4));      // 15\n\n  st.update(5, 5, 77);                           // update A[5] to 77\n  printf(\"              idx    0, 1, 2, 3, 4, 5, 6, 7\\n\");\n  printf(\"Now, modify A into {18,17,13,19,15,77,20,oo}\\n\");\n  printf(\"RMQ(1, 3) = %d\\n\", st.RMQ(1, 3));      // remains 13\n  printf(\"RMQ(4, 7) = %d\\n\", st.RMQ(4, 7));      // now 15\n  printf(\"RMQ(3, 4) = %d\\n\", st.RMQ(3, 4));      // remains 15\n\n  st.update(0, 3, 30);                           // update A[0..3] to 30\n  printf(\"              idx    0, 1, 2, 3, 4, 5, 6, 7\\n\");\n  printf(\"Now, modify A into {30,30,30,30,15,77,20,oo}\\n\");\n  printf(\"RMQ(1, 3) = %d\\n\", st.RMQ(1, 3));      // now 30\n  printf(\"RMQ(4, 7) = %d\\n\", st.RMQ(4, 7));      // remains 15\n  printf(\"RMQ(3, 4) = %d\\n\", st.RMQ(3, 4));      // remains 15\n\n  st.update(3, 3, 7);                            // update A[3] to 7\n  printf(\"              idx    0, 1, 2, 3, 4, 5, 6, 7\\n\");\n  printf(\"Now, modify A into {30,30,30, 7,15,77,20,oo}\\n\");\n  printf(\"RMQ(1, 3) = %d\\n\", st.RMQ(1, 3));      // now 7\n  printf(\"RMQ(4, 7) = %d\\n\", st.RMQ(4, 7));      // remains 15\n  printf(\"RMQ(3, 4) = %d\\n\", st.RMQ(3, 4));      // now 7\n\n  return 0;\n}\n"
            ],
            [
                "Union Find",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch2/ourown/unionfind_ds.cpp\n// Union-Find Disjoint Sets Library written in OOP manner, using both path compression and union by rank heuristics\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\n\nclass UnionFind {                                // OOP style\nprivate:\n  vi p, rank, setSize;                           // vi p is the key part\n  int numSets;\npublic:\n  UnionFind(int N) {\n    p.assign(N, 0); for (int i = 0; i < N; ++i) p[i] = i;\n    rank.assign(N, 0);                           // optional speedup\n    setSize.assign(N, 1);                        // optional feature\n    numSets = N;                                 // optional feature\n  }\n\n  int findSet(int i) { return (p[i] == i) ? i : (p[i] = findSet(p[i])); }\n  bool isSameSet(int i, int j) { return findSet(i) == findSet(j); }\n\n  int numDisjointSets() { return numSets; }      // optional\n  int sizeOfSet(int i) { return setSize[findSet(i)]; } // optional\n\n  void unionSet(int i, int j) {\n    if (isSameSet(i, j)) return;                 // i and j are in same set\n    int x = findSet(i), y = findSet(j);          // find both rep items\n    if (rank[x] > rank[y]) swap(x, y);           // keep x 'shorter' than y\n    p[x] = y;                                    // set x under y\n    if (rank[x] == rank[y]) ++rank[y];           // optional speedup\n    setSize[y] += setSize[x];                    // combine set sizes at y\n    --numSets;                                   // a union reduces numSets\n  }\n};\n\nint main() {\n  printf(\"Assume that there are 5 disjoint sets initially\\n\");\n  UnionFind UF(5); // create 5 disjoint sets\n  printf(\"%d\\n\", UF.numDisjointSets()); // 5\n  UF.unionSet(0, 1);\n  printf(\"%d\\n\", UF.numDisjointSets()); // 4\n  UF.unionSet(2, 3);\n  printf(\"%d\\n\", UF.numDisjointSets()); // 3\n  UF.unionSet(4, 3);\n  printf(\"%d\\n\", UF.numDisjointSets()); // 2\n  printf(\"isSameSet(0, 3) = %d\\n\", UF.isSameSet(0, 3)); // will return 0 (false)\n  printf(\"isSameSet(4, 3) = %d\\n\", UF.isSameSet(4, 3)); // will return 1 (true)\n  for (int i = 0; i < 5; i++) // findSet will return 1 for {0, 1} and 3 for {2, 3, 4}\n    printf(\"findSet(%d) = %d, sizeOfSet(%d) = %d\\n\", i, UF.findSet(i), i, UF.sizeOfSet(i));\n  UF.unionSet(0, 3);\n  printf(\"%d\\n\", UF.numDisjointSets()); // 1\n  for (int i = 0; i < 5; i++) // findSet will return 3 for {0, 1, 2, 3, 4}\n    printf(\"findSet(%d) = %d, sizeOfSet(%d) = %d\\n\", i, UF.findSet(i), i, UF.sizeOfSet(i));\n  return 0;\n}\n"
            ],
            [
                "Floyd Warshall (APAP)",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/floyd_warshall.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9; // INF = 1B, not 2^31-1 to avoid overflow\nconst int MAX_V = 450; // if |V| > 450, you cannot use Floyd Washall's\n\nint AM[MAX_V][MAX_V]; // it is better to store a big array in the heap\n\nint main() {\n  /*\n  // Graph in Figure 4.30\n  5 9\n  0 1 2\n  0 2 1\n  0 4 3\n  1 3 4\n  2 1 1\n  2 4 1\n  3 0 1\n  3 2 3\n  3 4 5\n  */\n\n  freopen(\"floyd_warshall_in.txt\", \"r\", stdin);\n\n  int V, E; scanf(\"%d %d\", &V, &E);\n  for (int u = 0; u < V; ++u) {\n    for (int v = 0; v < V; ++v)\n      AM[u][v] = INF;\n    AM[u][u] = 0;\n  }\n\n  for (int i = 0; i < E; ++i) {\n    int u, v, w; scanf(\"%d %d %d\", &u, &v, &w);\n    AM[u][v] = w;                                // directed graph\n  }\n\n  for (int k = 0; k < V; ++k)                    // loop order is k->u->v\n    for (int u = 0; u < V; ++u)\n      for (int v = 0; v < V; ++v)\n        AM[u][v] = min(AM[u][v], AM[u][k]+AM[k][v]);\n\n  for (int u = 0; u < V; ++u)\n    for (int v = 0; v < V; ++v)\n      printf(\"APSP(%d, %d) = %d\\n\", u, v, AM[u][v]);\n\n  return 0;\n}\n"
            ],
            [
                "MCBM",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/mcbm.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\n\nvi match, vis;                                   // global variables\nvector<vi> AL;\n\nint Aug(int L) {\n  if (vis[L]) return 0;                          // L visited, return 0\n  vis[L] = 1;\n  for (auto &R : AL[L])\n    if ((match[R] == -1) || Aug(match[R])) {\n      match[R] = L;                              // flip status\n      return 1;                                  // found 1 matching\n    }\n  return 0;                                      // no matching\n}\n\nbool isprime(int v) {\n  int primes[10] = {2,3,5,7,11,13,17,19,23,29};\n  for (int i = 0; i < 10; ++i)\n    if (primes[i] == v)\n      return true;\n  return false;\n}\n\nint main() {\n// inside int main()\n  // build bipartite graph with directed edge from left to right set\n\n/*\n  // Graph in Figure 4.37 can be built on the fly\n  // we know there are 6 vertices in this bipartite graph, left side are numbered 0,1,2, right side 3,4,5\n  int V = 6, Vleft = 3, set1[3] = {1,7,11}, set2[3] = {4,10,12};\n\n  // build the bipartite graph, only directed edge from left to right is needed\n  AL.assign(V, vi());\n  for (int i = 0; i < Vleft; ++i)\n    for (int j = 0; j < 3; ++j)\n      if (isprime(set1[i] + set2[j]))\n        AL[i].push_back(3 + j);\n*/\n\n  // For bipartite graph in Figure 4.38, V = 5, Vleft = 3 (vertex 0 unused)\n  // AL[0] = {} // dummy vertex, but you can choose to use this vertex\n  // AL[1] = {3, 4}\n  // AL[2] = {3}\n  // AL[3] = {}   // we use directed edges from left to right set only\n  // AL[4] = {}\n\n  int V = 5, Vleft = 3;                          // we ignore vertex 0\n  AL.assign(V, {});\n  AL[1] = {3, 4};\n  AL[2] = {3};\n\n  unordered_set<int> freeV;\n  for (int L = 0; L < Vleft; ++L)\n    freeV.insert(L);                             // initial assumption\n  match.assign(V, -1);\n  int MCBM = 0;\n  // Greedy pre-processing for trivial Augmenting Paths\n  // try commenting versus un-commenting this for-loop\n  for (int L = 0; L < Vleft; ++L) {              // O(V+E)\n    vi candidates;\n    for (auto &R : AL[L])\n      if (match[R] == -1)\n        candidates.push_back(R);\n    if ((int)candidates.size() > 0) {\n      ++MCBM;\n      freeV.erase(L);                            // L is matched\n      int a = rand()%(int)candidates.size();     // randomize this\n      match[candidates[a]] = L;\n    }\n  }                                              // for each free vertex\n  for (auto &f : freeV) {                        // (in random order)\n    vis.assign(Vleft, 0);                        // reset first\n    MCBM += Aug(f);                              // try to match f\n  }\n  cout << \"Found \" << MCBM << \" matchings\\n\";    // the answer is 2 for Figure 4.38\n\n  return 0;\n}\n"
            ],
            [
                "Hierholzer",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/hierholzer.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\n\nint N;\nvector<vi> AL;                                   // Directed graph\n\nvi hierholzer(int s) {\n  vi ans, idx(N, 0), st;\n  st.push_back(s);\n  while (!st.empty()) {\n    int u = st.back();\n    if (idx[u] < (int)AL[u].size()) {            // still has neighbor\n      st.push_back(AL[u][idx[u]]);\n      ++idx[u];\n    }\n    else {\n      ans.push_back(u);\n      st.pop_back();\n    }\n  }\n  reverse(ans.begin(), ans.end());\n  return ans;\n}\n\nint main() {\n  // The directed graph shown in Figure 4.40\n  N = 7;\n  AL.assign(N, {});\n  AL[0] = {1, 6}; // A->[B,G]\n  AL[1] = {2};    // B->C\n  AL[2] = {3, 4}; // C->[D,E]\n  AL[3] = {0};    // D->A\n  AL[4] = {5};    // E->F\n  AL[5] = {0, 2}; // F->[A,C]\n  AL[6] = {5};    // G->F\n  vi ans = hierholzer(0);\n  for (auto &u : ans)\n    cout << (char)('A'+u) << \" \";\n  cout << \"\\n\";\n  return 0;  \n}\n"
            ],
            [
                "Kruskal (MST)",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/mst/kruskal.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef tuple<int, int, int> iii;\ntypedef vector<int> vi;\n\n// UFDS code from ch2/ownlibrary/ufds.cpp\n// Union-Find Disjoint Sets Library written in OOP manner, using both path compression and union by rank heuristics\nclass UnionFind {                                // OOP style\nprivate:\n  vi p, rank, setSize;                           // vi p is the key part\n  int numSets;\npublic:\n  UnionFind(int N) {\n    p.assign(N, 0); for (int i = 0; i < N; ++i) p[i] = i;\n    rank.assign(N, 0);                           // optional speedup\n    setSize.assign(N, 1);                        // optional feature\n    numSets = N;                                 // optional feature\n  }\n  int findSet(int i) { return (p[i] == i) ? i : (p[i] = findSet(p[i])); }\n  bool isSameSet(int i, int j) { return findSet(i) == findSet(j); }\n  void unionSet(int i, int j) {\n    if (isSameSet(i, j)) return;                 // i and j are in same set\n    int x = findSet(i), y = findSet(j);          // find both rep items\n    if (rank[x] > rank[y]) swap(x, y);           // keep x 'shorter' than y\n    p[x] = y;                                    // set x under y\n    if (rank[x] == rank[y]) ++rank[y];           // optional speedup\n    setSize[y] += setSize[x];                    // combine set sizes at y\n    --numSets;                                   // a union reduces numSets\n  }\n  int numDisjointSets() { return numSets; }\n  int sizeOfSet(int i) { return setSize[findSet(i)]; }\n};\n\nint main() {\n  /*\n  // Graph in Figure 4.10 left, format: list of weighted edges\n  // This example shows another form of reading graph input\n  5 7\n  0 1 4\n  0 2 4\n  0 3 6\n  0 4 6\n  1 2 2\n  2 3 8\n  3 4 9\n  */\n\n  freopen(\"mst_in.txt\", \"r\", stdin);\n\n  // Kruskal's algorithm\n  int V, E; scanf(\"%d %d\", &V, &E);\n  vector<iii> EL(E);\n  for (int i = 0; i < E; ++i) {\n    int u, v, w; scanf(\"%d %d %d\", &u, &v, &w);  // read as (u, v, w)\n    EL[i] = {w, u, v};                           // reorder as (w, u, v)\n  }\n  sort(EL.begin(), EL.end());                    // sort by w, O(E log E)\n  // note: std::tuple has built-in comparison function\n\n  int mst_cost = 0, num_taken = 0;               // no edge has been taken\n  UnionFind UF(V);                               // all V are disjoint sets\n  // note: the runtime cost of UFDS is very light\n  for (int i = 0; i < E; ++i) {                  // up to O(E)\n    auto [w, u, v] = EL[i];                      // C++17 style\n    if (UF.isSameSet(u, v)) continue;            // already in the same CC\n    mst_cost += w;                               // add w of this edge\n    UF.unionSet(u, v);                           // link them\n    ++num_taken;                                 // 1 more edge is taken\n    if (num_taken == V-1) break;                 // optimization\n  }\n  // note: the number of disjoint sets must eventually be 1 for a valid MST\n  printf(\"MST cost = %d (Kruskal's)\\n\", mst_cost);\n\n  return 0;\n}\n"
            ],
            [
                "Prim (MST)",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/mst/prim.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<ii> vii;\n\nvector<vii> AL;                                  // the graph stored in AL\nvi taken;                                        // to avoid cycle\npriority_queue<ii> pq;                           // to select shorter edges\n// C++ STL priority_queue is a max heap, we use -ve sign to reverse order\n\nvoid process(int u) { // set u as taken and enqueue neighbors of u\n  taken[u] = 1;\n  for (auto &[v, w] : AL[u])\n    if (!taken[v])\n      pq.push({-w, -v});                         // sort by non-dec weight\n}                                                // then by inc id\n\nint main() {\n  /*\n  // Graph in Figure 4.10 left, format: list of weighted edges\n  // This example shows another form of reading graph input\n  5 7\n  0 1 4\n  0 2 4\n  0 3 6\n  0 4 6\n  1 2 2\n  2 3 8\n  3 4 9\n  */\n\n  freopen(\"mst_in.txt\", \"r\", stdin);\n\n// inside int main() --- assume the graph is stored in AL, pq is empty\n  int V, E; scanf(\"%d %d\", &V, &E);\n  AL.assign(V, vii());\n  for (int i = 0; i < E; ++i) {\n    int u, v, w; scanf(\"%d %d %d\", &u, &v, &w);  // read as (u, v, w)\n    AL[u].emplace_back(v, w);\n    AL[v].emplace_back(u, w);\n  }\n  taken.assign(V, 0);                            // no vertex is taken\n  process(0);                                    // take+process vertex 0\n  int mst_cost = 0, num_taken = 0;               // no edge has been taken\n  while (!pq.empty()) {                          // up to O(E)\n    auto [w, u] = pq.top(); pq.pop();            // C++17 style\n    w = -w; u = -u;                              // negate to reverse order\n    if (taken[u]) continue;                      // already taken, skipped\n    mst_cost += w;                               // add w of this edge\n    process(u);                                  // take+process vertex u\n    ++num_taken;                                 // 1 more edge is taken\n    if (num_taken == V-1) break;                 // optimization\n  }\n  printf(\"MST cost = %d (Prim's)\\n\", mst_cost);\n\n  return 0;\n}\n"
            ],
            [
                "Bellman Ford (SSSP)",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/sssp/bellman_ford.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<ii> vii;\n\nconst int INF = 1e9; // INF = 1B, not 2^31-1 to avoid overflow\n\nint main() {\n  /*\n  // Graph in Figure 4.18, has negative weight, but no negative cycle\n  5 5 0\n  0 1 1\n  0 2 10\n  1 3 2\n  2 3 -10\n  3 4 3\n\n  // Graph in Figure 4.19, negative cycle exists, Bellman Ford's can detect this\n  6 6 0\n  0 1 99\n  0 5 -99\n  1 2 15\n  2 3 0\n  3 1 -42\n  3 4 2\n  */\n\n  freopen(\"bellman_ford_in.txt\", \"r\", stdin);\n\n  int V, E, s; scanf(\"%d %d %d\", &V, &E, &s);\n  vector<vii> AL(V, vii());\n  while (E--) {\n    int u, v, w; scanf(\"%d %d %d\", &u, &v, &w);\n    AL[u].emplace_back(v, w);\n  }\n\n  // Bellman Ford's routine, basically = relax all E edges V-1 times\n  vi dist(V, INF); dist[s] = 0;                  // INF = 1e9 here\n  for (int i = 0; i < V-1; ++i) {                // total O(V*E)\n    bool modified = false;                       // optimization\n    for (int u = 0; u < V; ++u)                  // these two loops = O(E)\n      if (dist[u] != INF)                        // important check\n        for (auto &[v, w] : AL[u]) {             // C++17 style\n          if (dist[u]+w >= dist[v]) continue;    // not improving, skip\n          dist[v] = dist[u]+w;                   // relax operation\n          modified = true;                       // optimization\n        }\n    if (!modified) break;                        // optimization\n  }\n\n  bool hasNegativeCycle = false;\n  for (int u = 0; u < V; ++u)                    // one more pass to check\n    if (dist[u] != INF)\n      for (auto &[v, w] : AL[u])                 // C++17 style\n        if (dist[v] > dist[u]+w)                 // should be false\n          hasNegativeCycle = true;               // if true => -ve cycle\n  printf(\"Negative Cycle Exist? %s\\n\", hasNegativeCycle ? \"Yes\" : \"No\");\n\n  if (!hasNegativeCycle)\n    for (int u = 0; u < V; ++u)\n      printf(\"SSSP(%d, %d) = %d\\n\", s, u, dist[u]);\n\n  return 0;\n}\n"
            ],
            [
                "Dijkstra (SSSP)",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/sssp/dijkstra.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<ii> vii;\n\nconst int INF = 1e9; // INF = 1B, not 2^31-1 to avoid overflow\n\nint main() {\n  /*\n  // Graph in Figure 4.17\n  5 7 0\n  0 1 2\n  0 2 6\n  0 3 7\n  1 3 3\n  1 4 6\n  2 4 1\n  3 4 5\n  */\n\n  freopen(\"dijkstra_in.txt\", \"r\", stdin);\n\n  int V, E, s; scanf(\"%d %d %d\", &V, &E, &s);\n  vector<vii> AL(V, vii());\n  while (E--) {\n    int u, v, w; scanf(\"%d %d %d\", &u, &v, &w);\n    AL[u].emplace_back(v, w);                    // directed graph\n  }\n\n  vi dist(V, INF); dist[s] = 0;                  // INF = 1e9 here\n\n  // Original Dijkstra's algorithm\n  /*\n  set<ii> pq;                                    // balanced BST version\n  for (int u = 0; u < V; ++u)                    // dist[u] = INF\n    pq.insert({dist[u], u});                     // but dist[s] = 0\n\n  // sort the pairs by non-decreasing distance from s\n  while (!pq.empty()) {                          // main loop\n    auto [d, u] = *pq.begin();                   // shortest unvisited u\n    pq.erase(pq.begin());\n    for (auto &[v, w] : AL[u]) {                 // all edges from u\n      if (dist[u]+w >= dist[v]) continue;        // not improving, skip\n      pq.erase(pq.find({dist[v], v}));           // erase old pair\n      dist[v] = dist[u]+w;                       // relax operation\n      pq.insert({dist[v], v});                   // enqueue better pair\n    }\n  }\n  */\n\n  // (Modified) Dijkstra's algorithm\n  priority_queue<ii, vector<ii>, greater<ii>> pq; pq.push({0, s});\n\n  // sort the pairs by non-decreasing distance from s\n  while (!pq.empty()) {                          // main loop\n    auto [d, u] = pq.top(); pq.pop();            // shortest unvisited u\n    if (d > dist[u]) continue;                   // a very important check\n    for (auto &[v, w] : AL[u]) {                 // all edges from u\n      if (dist[u]+w >= dist[v]) continue;        // not improving, skip\n      dist[v] = dist[u]+w;                       // relax operation\n      pq.push({dist[v], v});                     // enqueue better pair\n    }\n  }\n\n  for (int u = 0; u < V; ++u)\n    printf(\"SSSP(%d, %d) = %d\\n\", s, u, dist[u]);\n\n  return 0;\n}\n"
            ],
            [
                "BFS (SSSP)",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/sssp/bfs.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> ii; // In this chapter, we will frequently use these\ntypedef vector<ii> vii; // three data type shortcuts. They may look cryptic\ntypedef vector<int> vi; // but shortcuts are useful in competitive programming\n\nconst int INF = 1e9; // INF = 1B, not 2^31-1 to avoid overflow\n\nvi p;                                            // addition:parent vector\n\nvoid printPath(int u) {                          // extract info from vi p\n  if (p[u] == -1) { printf(\"%d\", u); return; }\n  printPath(p[u]);                               // output format: s -> ... -> t\n  printf(\" %d\", u);\n}\n\nint main() {\n  /*\n  // Graph in Figure 4.3, format: list of unweighted edges\n  // This example shows another form of reading graph input\n  13 16\n  0 1    1 2    2  3   0  4   1  5   2  6    3  7   5  6\n  4 8    8 9    5 10   6 11   7 12   9 10   10 11  11 12\n  */\n\n  freopen(\"bfs_in.txt\", \"r\", stdin);\n\n  int V, E; scanf(\"%d %d\", &V, &E);\n  vector<vii> AL(V, vii());\n  for (int i = 0; i < E; ++i) {\n    int a, b; scanf(\"%d %d\", &a, &b);\n    AL[a].emplace_back(b, 0);\n    AL[b].emplace_back(a, 0);\n  }\n\n  // as an example, we start from this source, see Figure 4.3\n  int s = 5;\n\n  // BFS routine inside int main() -- we do not use recursion\n  vi dist(V, INF); dist[s] = 0;                  // INF = 1e9 here\n  queue<int> q; q.push(s);\n  p.assign(V, -1);                               // p is global\n\n  int layer = -1;                                // for output printing\n  bool isBipartite = true;                       // additional feature\n\n  while (!q.empty()) {\n    int u = q.front(); q.pop();\n    if (dist[u] != layer) printf(\"\\nLayer %d: \", dist[u]);\n    layer = dist[u];\n    printf(\"visit %d, \", u);\n    for (auto &[v, w] : AL[u]) {                 // C++17 style, w ignored\n      if (dist[v] == INF) {\n        dist[v] = dist[u]+1;                     // dist[v] != INF now\n        p[v] = u;                                // parent of v is u\n        q.push(v);                               // for next iteration\n      }\n      else if ((dist[v]%2) == (dist[u]%2))       // same parity\n        isBipartite = false;\n    }\n  }\n\n  printf(\"\\nShortest path: \");\n  printPath(7), printf(\"\\n\");\n  printf(\"isBipartite? %d\\n\", isBipartite);\n\n  return 0;\n}\n"
            ],
            [
                "Toposort",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/traversal/toposort.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> ii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\n\nenum { UNVISITED = -1, VISITED = -2 };                     // basic flags\n\n// these variables have to be global to be easily accessible by our recursion (other ways exist)\nvector<vii> AL;\nvi dfs_num; \nvi ts;\n\nvoid toposort(int u) {\n  dfs_num[u] = VISITED;\n  for (auto &[v, w] : AL[u])\n    if (dfs_num[v] == UNVISITED)\n      toposort(v);\n  ts.push_back(u);                               // this is the only change\n}\n\nint main() {\n  /*\n  // Example of a Directed Acyclic Graph in Figure 4.4 (for toposort)\n  8\n  2 1 0 2 0\n  2 2 0 3 0\n  2 3 0 5 0\n  1 4 0\n  0\n  0\n  0\n  1 6 0\n  */\n\n  freopen(\"toposort_in.txt\", \"r\", stdin);\n\n  int V; scanf(\"%d\", &V);\n  AL.assign(V, vii());\n  for (int u = 0; u < V; ++u) {\n    int k; scanf(\"%d\", &k);\n    while (k--) {\n      int v, w; scanf(\"%d %d\", &v, &w);\n      AL[u].emplace_back(v, w);\n    }\n  }\n\n  // make sure that the given graph is DAG\n  printf(\"Topological Sort (the input graph must be DAG)\\n\");\n  dfs_num.assign(V, UNVISITED);                  // global variable\n  ts.clear();                                    // global variable\n  for (int u = 0; u < V; ++u)                    // same as finding CCs\n    if (dfs_num[u] == UNVISITED)\n      toposort(u);\n  reverse(ts.begin(), ts.end());                 // reverse ts or\n  for (auto &u : ts)                             // simply read the content\n    printf(\" %d\", u);                            // of ts backwards\n  printf(\"\\n\");\n\n  return 0;\n}\n"
            ],
            [
                "Trie",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch6/Trie.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct vertex {\n  char alphabet;\n  bool exist;\n  vector<vertex*> child;\n  vertex(char a): alphabet(a), exist(false) { child.assign(26, NULL); }\n};\n\nclass Trie {                                     // this is TRIE\nprivate:                                         // NOT Suffix Trie\n  vertex* root;\npublic:\n  Trie() { root = new vertex('!'); }\n\n  void insert(string word) {                     // insert a word into trie\n    vertex* cur = root;\n    for (int i = 0; i < (int)word.size(); ++i) { // O(n)\n      int alphaNum = word[i]-'A';\n      if (cur->child[alphaNum] == NULL)          // add new branch if NULL\n        cur->child[alphaNum] = new vertex(word[i]);\n      cur = cur->child[alphaNum];\n    }\n    cur->exist = true;\n  }\n\n  bool search(string word) {                     // true if word in trie\n    vertex* cur = root;\n    for (int i = 0; i < (int)word.size(); ++i) { // O(m)\n      int alphaNum = word[i]-'A';\n      if (cur->child[alphaNum] == NULL)          // not found\n        return false;\n      cur = cur->child[alphaNum];\n    }\n    return cur->exist;                           // check exist flag\n  }\n\n  bool startsWith(string prefix) {               // true if match prefix\n    vertex* cur = root;\n    for (int i = 0; i < (int)prefix.size(); ++i) {\n      int alphaNum = prefix[i]-'A';\n      if (cur->child[alphaNum] == NULL)          // not found\n        return false;\n      cur = cur->child[alphaNum];\n    }\n    return true;                                 // reach here, return true\n  }\n};\n\nint main() {\n  Trie T;\n  set<string> S = {\"CAR\", \"CAT\", \"RAT\"};\n  for (auto &str : S) {\n    printf(\"Insert %s\\n\", str.c_str());\n    T.insert(str);\n  }\n  printf(\"'CAR' exist? %d\\n\", T.search(\"CAR\"));  // 1 (true)\n  printf(\"'DOG' exist? %d\\n\", T.search(\"DOG\"));  // 0 (false)\n  printf(\"Starts with 'CA' exist? %d\\n\", T.startsWith(\"CA\")); // 1 (true)\n  printf(\"Starts with 'Z' exist? %d\\n\", T.startsWith(\"Z\")); // 0 (false)\n  printf(\"Starts with 'AT' exist? %d\\n\", T.startsWith(\"AT\")); // 0 (false) for this Trie, but in a Suffix Trie, we have a suffix \"AT\" (from \"CAT\" or \"RAT\") that starts with \"AT\"\n  return 0;\n}\n"
            ],
            [
                "Max flow / Min Cut",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch8/maxflow.cpp\n// Disclaimer: This code is a hybrid between old CP1-2-3 implementation of\n// Edmonds Karp's algorithm -- re-written in OOP fashion and the fast\n// Dinic's algorithm implementation by\n// https://github.com/jaehyunp/stanfordacm/blob/master/code/Dinic.cc\n// This code is written in modern C++17 standard\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef tuple<int, ll, ll> edge;\ntypedef vector<int> vi;\ntypedef pair<int, int> ii;\n\nconst ll INF = 1e18;                             // large enough\n\nclass max_flow {\nprivate:\n  int V;\n  vector<edge> EL;\n  vector<vi> AL;\n  vi d, last;\n  vector<ii> p;\n\n  bool BFS(int s, int t) {                       // find augmenting path\n    d.assign(V, -1); d[s] = 0;\n    queue<int> q({s});\n    p.assign(V, {-1, -1});                       // record BFS sp tree\n    while (!q.empty()) {\n      int u = q.front(); q.pop();\n      if (u == t) break;                         // stop as sink t reached\n      for (auto &idx : AL[u]) {                  // explore neighbors of u\n        auto &[v, cap, flow] = EL[idx];          // stored in EL[idx]\n        if ((cap-flow > 0) && (d[v] == -1))      // positive residual edge\n          d[v] = d[u]+1, q.push(v), p[v] = {u, idx}; // 3 lines in one!\n      }\n    }\n    return d[t] != -1;                           // has an augmenting path\n  }\n\n  ll send_one_flow(int s, int t, ll f = INF) {   // send one flow from s->t\n    if (s == t) return f;                        // bottleneck edge f found\n    auto &[u, idx] = p[t];\n    auto &cap = get<1>(EL[idx]), &flow = get<2>(EL[idx]);\n    ll pushed = send_one_flow(s, u, min(f, cap-flow));\n    flow += pushed;\n    auto &rflow = get<2>(EL[idx^1]);             // back edge\n    rflow -= pushed;                             // back flow\n    return pushed;\n  }\n\n  ll DFS(int u, int t, ll f = INF) {             // traverse from s->t\n    if ((u == t) || (f == 0)) return f;\n    for (int &i = last[u]; i < (int)AL[u].size(); ++i) { // from last edge\n      auto &[v, cap, flow] = EL[AL[u][i]];\n      if (d[v] != d[u]+1) continue;              // not part of layer graph\n      if (ll pushed = DFS(v, t, min(f, cap-flow))) {\n        flow += pushed;\n        auto &rflow = get<2>(EL[AL[u][i]^1]);     // back edge\n        rflow -= pushed;\n        return pushed;\n      }\n    }\n    return 0;\n  }\n\npublic:\n  max_flow(int initialV) : V(initialV) {\n    EL.clear();\n    AL.assign(V, vi());\n  }\n\n  // if you are adding a bidirectional edge u<->v with weight w into your\n  // flow graph, set directed = false (default value is directed = true)\n  void add_edge(int u, int v, ll w, bool directed = true) {\n    if (u == v) return;                          // safeguard: no self loop\n    EL.emplace_back(v, w, 0);                    // u->v, cap w, flow 0\n    AL[u].push_back(EL.size()-1);                // remember this index\n    EL.emplace_back(u, directed ? 0 : w, 0);     // back edge\n    AL[v].push_back(EL.size()-1);                // remember this index\n  }\n\n  ll edmonds_karp(int s, int t) {\n    ll mf = 0;                                   // mf stands for max_flow\n    while (BFS(s, t)) {                          // an O(V*E^2) algorithm\n      ll f = send_one_flow(s, t);                // find and send 1 flow f\n      if (f == 0) break;                         // if f == 0, stop\n      mf += f;                                   // if f > 0, add to mf\n    }\n    return mf;\n  }\n\n  ll dinic(int s, int t) {\n    ll mf = 0;                                   // mf stands for max_flow\n    while (BFS(s, t)) {                          // an O(V^2*E) algorithm\n      last.assign(V, 0);                         // important speedup\n      while (ll f = DFS(s, t))                   // exhaust blocking flow\n        mf += f;\n    }\n    return mf;\n  }\n};\n\nint main() {\n  /*\n  // Graph in Figure 8.11\n  4 0 3\n  2 1 8 2 8\n  2 2 1 3 8\n  1 3 8\n  0\n  // the max flow value of that graph should be 16\n  */\n\n  freopen(\"maxflow_in.txt\", \"r\", stdin);\n\n  int V, s, t; scanf(\"%d %d %d\", &V, &s, &t);\n  max_flow mf(V);\n  for (int u = 0; u < V; ++u) {\n    int k; scanf(\"%d\", &k);\n    while (k--) {\n      int v, w; scanf(\"%d %d\", &v, &w);\n      mf.add_edge(u, v, w);                      // default: directed edge\n    }\n  }\n\n  // printf(\"%lld\\n\", mf.edmonds_karp(s, t));\n  printf(\"%lld\\n\", mf.dinic(s, t));\n\n  return 0;\n}\n"
            ],
            [
                "Min Cost Max Flow",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch9/mcmf.cpp\n// This code uses new C++17 structured binding\n// use this compiler setting \"g++ -O2 -std=gnu++17 {cpp17file}\"\n\n// Disclaimer: This code is a hybrid between old CP1-2-3 implementation of\n// Edmonds Karp's algorithm -- re-written in OOP fashion and the fast\n// Dinic's algorithm implementation by\n// https://github.com/jaehyunp/stanfordacm/blob/master/code/Dinic.cc\n// This code is written in modern C++17 standard\n\n// We replace BFS with SPFA\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef tuple<int, ll, ll, ll> edge;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nconst ll INF = 1e18; // INF = 1e18, not 2^63-1 to avoid overflow\n\nclass min_cost_max_flow {\nprivate:\n  int V;\n  ll total_cost;\n  vector<edge> EL;\n  vector<vi> AL;\n  vll d;\n  vi last, vis;\n\n  bool SPFA(int s, int t) { // SPFA to find augmenting path in residual graph\n    d.assign(V, INF); d[s] = 0; vis[s] = 1;\n    queue<int> q({s});\n    while (!q.empty()) {\n      int u = q.front(); q.pop(); vis[u] = 0;\n      for (auto &idx : AL[u]) {                  // explore neighbors of u\n        auto &[v, cap, flow, cost] = EL[idx];          // stored in EL[idx]\n        if ((cap-flow > 0) && (d[v] > d[u] + cost)) {      // positive residual edge\n          d[v] = d[u]+cost;\n          if(!vis[v]) q.push(v), vis[v] = 1;\n        }\n      }\n    }\n    return d[t] != INF;                           // has an augmenting path\n  }\n\n  ll DFS(int u, int t, ll f = INF) {             // traverse from s->t\n    if ((u == t) || (f == 0)) return f;\n    vis[u] = 1;\n    for (int &i = last[u]; i < (int)AL[u].size(); ++i) { // from last edge\n      auto &[v, cap, flow, cost] = EL[AL[u][i]];\n      if (!vis[v] && d[v] == d[u]+cost) {                      // in current layer graph\n        if (ll pushed = DFS(v, t, min(f, cap-flow))) {\n      total_cost += pushed * cost;\n          flow += pushed;\n          auto &[rv, rcap, rflow, rcost] = EL[AL[u][i]^1]; // back edge\n          rflow -= pushed;\n          vis[u] = 0;\n          return pushed;\n        }\n      }\n    }\n    vis[u] = 0;\n    return 0;\n  }\n\npublic:\n  min_cost_max_flow(int initialV) : V(initialV), total_cost(0) {\n    EL.clear();\n    AL.assign(V, vi());\n    vis.assign(V, 0);\n  }\n\n  // if you are adding a bidirectional edge u<->v with weight w into your\n  // flow graph, set directed = false (default value is directed = true)\n  void add_edge(int u, int v, ll w, ll c, bool directed = true) {\n    if (u == v) return;                          // safeguard: no self loop\n    EL.emplace_back(v, w, 0, c);                 // u->v, cap w, flow 0, cost c\n    AL[u].push_back(EL.size()-1);                // remember this index\n    EL.emplace_back(u, 0, 0, -c);                // back edge\n    AL[v].push_back(EL.size()-1);                // remember this index\n    if (!directed) add_edge(v, u, w, c);         // add again in reverse\n  }\n\n  pair<ll, ll> mcmf(int s, int t) {\n    ll mf = 0;                                   // mf stands for max_flow\n    while (SPFA(s, t)) {                          // an O(V^2*E) algorithm\n      last.assign(V, 0);                         // important speedup\n      while (ll f = DFS(s, t))                   // exhaust blocking flow\n        mf += f;\n    }\n    return {mf, total_cost};\n  }\n};\n\nint main() {\n  int V, E, s, t; scanf(\"%d %d %d %d\", &V, &E, &s, &t);\n  min_cost_max_flow mf(V);\n  for (int i = 0; i < E; ++i) {\n    int u, v, w, c; scanf(\"%d %d %d %d\", &u, &v, &w, &c);\n    mf.add_edge(u, v, w, c);                      // default: directed edge\n  }\n  pair<ll, ll> res = mf.mcmf(s, t);\n  printf(\"%lld %lld\\n\", res.first, res.second);\n  return 0;\n}\n"
            ]
        ]
    },
    "python3": {
        "repr": "Python 3",
        "default": "print('Hello world!')",
        "template": [
            [
                "Quick Select",
                "#SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch2/nonlineards/QuickSelect.py\nimport random\n\ndef swap(A, i, j): \n    A[i],A[j] = A[j],A[i] \n    return A\n\ndef Partition(A, l, r):\n    p = A[l]                                     # p is the pivot\n    m = l                                        # S1 and S2 are empty\n    for k in range(l+1, r+1):                    # explore unknown region\n        if A[k] < p:                             # case 2\n            m += 1\n            swap(A, k, m)\n        # notice that we do nothing in case 1: a[k] >= p\n    swap(A, l, m)                                # swap pivot with a[m]\n    return m                                     # return pivot index\n\ndef RandPartition(A, l, r):\n    p = random.randint(l, r)                     # select a random pivot\n    swap(A, l, p)                                # swap A[p] with A[l]\n    return Partition(A, l, r)\n\ndef QuickSelect(A, l, r, k):                     # expected O(n)\n    if l == r:\n        return A[l]\n    q = RandPartition(A, l, r)                   # O(n)\n    if q+1 == k:\n        return A[q]\n    elif q+1 > k:\n        return QuickSelect(A, l, q-1, k)\n    else:\n        return QuickSelect(A, q+1, r, k)\n\ndef main():\n    A = [2, 8, 7, 1, 5, 4, 6, 3]                 # permutation of [1..8]\n\n    print(\"{}\".format(QuickSelect(A, 0, 7, 8)))  # the output must be 8\n    print(\"{}\".format(QuickSelect(A, 0, 7, 7)))  # the output must be 7\n    print(\"{}\".format(QuickSelect(A, 0, 7, 6)))  # the output must be 6\n    print(\"{}\".format(QuickSelect(A, 0, 7, 5)))  # the output must be 5\n    print(\"{}\".format(QuickSelect(A, 0, 7, 4)))  # the output must be 4\n    print(\"{}\".format(QuickSelect(A, 0, 7, 3)))  # the output must be 3\n    print(\"{}\".format(QuickSelect(A, 0, 7, 2)))  # the output must be 2\n    print(\"{}\".format(QuickSelect(A, 0, 7, 1)))  # the output must be 1\n\n    # try experimenting with the content of array A to see the behavior of \"QuickSelect\"\n\nmain()\n"
            ],
            [
                "Fenwick Tree",
                "#SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch2/ourown/fenwicktree_ds.py\nclass FTree:\n    def __init__(self, f):\n        self.n = len(f)\n        self.ft = [0] * (self.n + 1)\n\n        for i in range(1, self.n + 1):\n            self.ft[i] += f[i - 1]\n            if i + self.lsone(i) <= self.n:\n                self.ft[i + self.lsone(i)] += self.ft[i]\n\n    def lsone(self, s):\n        return s & (-s)\n\n    def query(self, i, j):\n        if i > 1:\n            return self.query(1, j) - self.query(1, i - 1)\n\n        s = 0\n        while j > 0:\n            s += self.ft[j]\n            j -= self.lsone(j)\n\n        return s\n\n    def update(self, i, v):\n        while i <= self.n:\n            self.ft[i] += v\n            i += self.lsone(i)\n\n    def select(self, k):\n        p = 1\n        while (p * 2) <= self.n: p *= 2\n\n        i = 0\n        while p > 0:\n            if k > self.ft[i + p]:\n                k -= self.ft[i + p]\n                i += p\n            p //= 2\n\n        return i + 1\n\nclass RUPQ:\n    def __init__(self, n):\n        self.ftree = FTree([0] * n)\n\n    def query(self, i):\n        return self.ftree.query(1, i)\n\n    def update(self, i, j, v):\n        self.ftree.update(i, v)\n        self.ftree.update(j + 1, -v)\n\nclass RURQ:\n    def __init__(self, n):\n        self.f = FTree([0] * n)\n        self.r = RUPQ(n)\n\n    def query(self, i, j):\n        if i > 1:\n            return self.query(1, j) - self.query(1, i - 1)\n        return self.r.query(j) * j - self.f.query(1, j)\n\n    def update(self, i, j, v):\n        self.r.update(i, j, v)\n        self.f.update(i, v * (i - 1))\n        self.f.update(j + 1, -1 * v * j)\n\n\nf = [0, 1, 0, 1, 2, 3, 2, 1, 1, 0]\nft = FTree(f)\nprint(ft.query(1, 6) == 7)\nprint(ft.query(1, 3) == 1)\nprint(ft.select(7) == 6)\nft.update(5, 1)\nprint(ft.query(1, 10) == 12)\n\nr = RUPQ(10)\nr.update(2, 9, 7)\nr.update(6, 7, 3)\nprint(r.query(1) == 0)\nprint(r.query(2) == 7)\nprint(r.query(3) == 7)\nprint(r.query(4) == 7)\nprint(r.query(5) == 7)\nprint(r.query(6) == 10)\nprint(r.query(7) == 10)\nprint(r.query(8) == 7)\nprint(r.query(9) == 7)\nprint(r.query(10) == 0)\n\nr = RURQ(10)\nr.update(2, 9, 7)\nr.update(6, 7, 3)\nprint(r.query(3, 5) == 21)\nprint(r.query(7, 8) == 17)\n\n# Example for https://open.kattis.com/problems/fenwick\n# from sys import stdin, stdout\n#\n# def main():\n#     n, q = [int(i) for i in stdin.readline().split(' ')]\n#     f = FTree([0] * n)\n#     for l in stdin.read()[:-1].split('\\n'):\n#         a = l.split(' ')\n#         if a[0] == '?':\n#             if a[1] == '0':\n#                 stdout.write(\"0\\n\")\n#             else:\n#                 stdout.write(\"{}\\n\".format(f.q(1, int(a[1]))))\n#         else:\n#             f.u(int(a[1]) + 1, int(a[2]))\n#\n# main()\n"
            ],
            [
                "Segment Tree",
                "#SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch2/ourown/segmenttree_ds.py\nclass STree:\n    def __init__(self, l):\n        self.l = l\n        self.n = len(l)\n        self.st = [0] * (4 * self.n)\n        self.islazy = [False] * (4 * self.n)\n        self.lazy = [0] * (4 * self.n)\n\n        self.build(1, 0, self.n - 1)\n\n    def left(self, p):\n        return p << 1\n\n    def right(self, p):\n        return (p << 1) + 1\n\n    def build(self, p, l, r):\n        if (l == r):\n            self.st[p] = l\n        else:\n            self.build(self.left(p), l, (l + r) // 2)\n            self.build(self.right(p), (l + r) // 2 + 1, r)\n            p1 = self.st[self.left(p)]\n            p2 = self.st[self.right(p)]\n            if self.l[p1] <= self.l[p2]:\n                self.st[p] = p1\n            else:\n                self.st[p] = p2\n\n    def _q(self, p, pl, pr, fr, to):\n        if fr > pr or to < pl:\n            return -1, -1\n        if self.islazy[p]:\n            return fr, self.lazy[p]\n        if fr <= pl and to >= pr:\n            return self.st[p], self.l[self.st[p]]\n\n        res1 = self._q(self.left(p), pl, (pl + pr) // 2, fr, to)\n        res2 = self._q(self.right(p), (pl + pr) // 2 + 1, pr, fr, to)\n\n        if (res1[0] == -1):\n            return res2\n        elif res2[0] == -1:\n            return res1\n        elif res1[1] <= res2[1]:\n            return res1\n        else:\n            return res2\n\n    def _u(self, p, pl, pr, fr, to, newval):\n        if fr > pr or to < pl:\n            return self.st[p]\n\n        if fr == pl and to == pr:\n            if fr == to:\n                self.l[pl] = newval\n                self.islazy[p] = False\n            else:\n                self.lazy[p] = newval\n                self.islazy[p] = True\n\n            self.st[p] = fr\n            return self.st[p]\n\n        pm = (pl + pr) // 2\n\n        if self.islazy[p]:\n            self.islazy[p] = False\n            self.islazy[self.left(p)] = True\n            self.islazy[self.right(p)] = True\n            self.lazy[self.left(p)] = self.lazy[p]\n            self.lazy[self.right(p)] = self.lazy[p]\n            self.st[self.left(p)] = pl\n            self.st[self.right(p)] = pm\n\n        p1 = self._u(self.left(p), pl, pm, max(fr, pl), min(to, pm), newval)\n        p2 = self._u(self.right(p), pm + 1, pr, max(fr, pm + 1), min(to, pr), newval)\n\n        if self.l[p1] <= self.l[p2]:\n            self.st[p] = p1\n        else:\n            self.st[p] = p2\n        return self.st[p]\n\n    def q(self, fr, to):\n        return self._q(1, 0, self.n - 1, fr, to)[0]\n\n    def u(self, fr, to, val):\n        return self._u(1, 0, self.n - 1, fr, to, val)\n\n\nl = [18, 17, 13, 19, 15, 11, 20]\nst = STree(l)\nprint(st.q(0, 0) == 0)\nprint(st.q(1, 3) == 2)\nprint(st.q(4, 6) == 5)\nst.u(5, 5, 99)\nprint(st.q(1, 3) == 2)\nprint(st.q(4, 6) == 4)\nst.u(0, 3, 7)\nprint(st.q(1, 3) == 1)\nprint(st.q(3, 6) == 3)\nst.u(3, 4, 5)\nprint(st.q(1, 3) == 3)\nprint(st.q(4, 6) == 4)\n"
            ],
            [
                "Union Find",
                "#SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch2/ourown/unionfind_ds.py\nclass UFDS:\n    def __init__(self, n):\n        self.parents = list(range(n))\n        self.ranks = [0] * n\n        self.sizes = [1] * n\n        self.numdisjoint = n\n\n    def find(self, x):\n        xp = x\n        children = []\n        while xp != self.parents[xp]:\n            children.append(xp)\n            xp = self.parents[xp]\n        for c in children:\n            self.parents[c] = xp\n        return xp\n\n    def union(self, a, b):\n        ap = self.find(a)\n        bp = self.find(b)\n        if ap == bp:\n            return\n\n        if self.ranks[ap] < self.ranks[bp]:\n            self.parents[ap] = bp\n            self.sizes[bp] += self.sizes[ap]\n        elif self.ranks[bp] < self.ranks[ap]:\n            self.parents[bp] = ap\n            self.sizes[ap] += self.sizes[bp]\n        else:\n            self.parents[bp] = ap\n            self.ranks[ap] += 1\n            self.sizes[ap] += self.sizes[bp]\n\n        self.numdisjoint -= 1\n\n    def size(self, x):\n        return self.sizes[self.find(x)]\n\n\nu = UFDS(8)\nprint(u.numdisjoint == 8)\nu.union(1, 2)\nprint(u.find(1) == u.find(2))\nprint(u.find(1) != u.find(3))\nprint(u.find(2) != u.find(3))\nprint(u.size(1) == 2)\nprint(u.size(2) == 2)\nprint(u.size(3) == 1)\nprint(u.numdisjoint == 7)\nu.union(1, 3)\nprint(u.find(1) == u.find(2))\nprint(u.find(1) == u.find(3))\nprint(u.find(2) == u.find(3))\nprint(u.find(2) != u.find(4))\nprint(u.size(1) == 3)\nprint(u.size(2) == 3)\nprint(u.size(3) == 3)\nprint(u.numdisjoint == 6)\nu.union(2, 4)\nprint(u.find(1) == u.find(3))\nprint(u.find(2) == u.find(4))\nprint(u.size(1) == 4)\nprint(u.size(2) == 4)\nprint(u.numdisjoint == 5)\nu.union(2, 3)\nprint(u.size(1) == 4)\nprint(u.size(2) == 4)\nprint(u.numdisjoint == 5)\n\n# Example for https://open.kattis.com/problems/unionfind\n# from sys import stdin, stdout\n#\n# def main():\n#     n, q = [int(i) for i in stdin.readline().split(' ')]\n#     u = UFDS(n)\n#     for l in stdin.read()[:-1].split('\\n'):\n#         c, a, b = l.split(' ')\n#         if c == '?':\n#             stdout.write(\"yes\\n\" if u.find(int(a)) == u.find(int(b)) else \"no\\n\")\n#         else:\n#             u.union(int(a), int(b))\n#\n# main()\n"
            ],
            [
                "Floyd Warshall (APAP)",
                "#SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/floyd_warshall.py\ndef main():\n\tINF = int(1e9)\n\tMAX_V = 450 # if |V| > 450, you cannot use Floyd Washall's\n\n\tAM = [[INF for j in range(MAX_V)] for i in range(MAX_V)]\n\n\t# Graph in Figure 4.30\n\t# 5 9\n\t# 0 1 2\n\t# 0 2 1\n\t# 0 4 3\n\t# 1 3 4\n\t# 2 1 1\n\t# 2 4 1\n\t# 3 0 1\n\t# 3 2 3\n\t# 3 4 5\n\n\tf = open(\"floyd_warshall_in.txt\", \"r\")\n\tV, E = map(int, f.readline().split(\" \"))\n\tfor u in range(V):\n\t\tAM[u][u] = 0\n\n\tfor i in range(E):\n\t\tu, v, w = map(int, f.readline().split(\" \"))\n\t\tAM[u][v] = w \t# directed graph\n\n\tfor k in range(V):\t# loop order is k->u->v\n\t\tfor u in range(V):\n\t\t\tfor v in range(V):\n\t\t\t\tAM[u][v] = min(AM[u][v], AM[u][k] + AM[k][v])\n\n\tfor u in range(V):\n\t\tfor v in range(V):\n\t\t\tprint(\"APSP({}, {}) = {}\".format(u, v, AM[u][v]))\n\nmain()"
            ],
            [
                "MCBM",
                "#SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/mcbm.py\nimport random\n\nmatch = []\nvis = []\nAL = []\n\ndef Aug(L):\n    global match, vis, AL\n\n    if vis[L]:\n        return 0\n    vis[L] = 1\n    for R in AL[L]:\n        if match[R] == -1 or Aug(match[R]):\n            match[R] = L\n            return 1\n    return 0\n\ndef main():\n    global match, vis, AL\n\n    V = 5\n    Vleft = 3\n    AL = [list() for _ in range(V)]\n    AL[1] = [3, 4]\n    AL[2] = [3]\n\n    freeV = set()\n    for L in range(Vleft):\n        freeV.add(L)\n    match = [-1] * V\n    MCBM = 0\n\n    for L in range(Vleft):\n        candidates = []\n        for R in AL[L]:\n            if match[R] == -1:\n                candidates.append(R)\n        if len(candidates) > 0:\n            MCBM += 1\n            freeV.remove(L)\n            a = random.randrange(len(candidates))\n            match[candidates[a]] = L\n \n    for f in freeV:\n        vis = [0] * Vleft\n        MCBM += Aug(f)\n\n    print('Found %d matchings' % MCBM)\n\nmain()\n"
            ],
            [
                "Hierholzer",
                "#SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/hierholzer.py\nimport sys\n\nN = 0\nAL = []\n\ndef hierholzer(s):\n  global AL, N\n\n  ans = []\n  idx = [0] * N\n  st = [s]\n\n  while len(st) != 0:\n    u = st[-1]\n    if idx[u] < len(AL[u]):\n      st.append(AL[u][idx[u]])\n      idx[u] += 1\n    else:\n      ans.append(u)\n      st.pop()\n\n  ans = ans[::-1]\n  return ans\n\n\ndef main():\n  global AL, N\n\n  N = 7\n  AL = [list() for _ in range(N)]\n  AL[0] = [1, 6]\n  AL[1] = [2]\n  AL[2] = [3, 4]\n  AL[3] = [0]\n  AL[4] = [5]\n  AL[5] = [0, 2]\n  AL[6] = [5]\n\n  ans = hierholzer(0)\n\n  for u in ans:\n    sys.stdout.write(str(chr(ord('A')+u))+' ')\n  sys.stdout.write('\\n')\n\n\nmain()\n"
            ],
            [
                "Kruskal (MST)",
                "#SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/mst/kruskal.py\nfrom heapq import heappush, heappop\n\n# Union-Find Disjoint Sets Library written in OOP manner\n# using both path compression and union by rank heuristics\nclass UnionFind:                                # OOP style\n    def __init__(self, N):\n        self.p = [i for i in range(N)]\n        self.rank = [0 for i in range(N)]\n        self.setSize = [1 for i in range(N)]\n        self.numSets = N\n\n    def findSet(self, i):\n        if (self.p[i] == i):\n            return i\n        else:\n            self.p[i] = self.findSet(self.p[i])\n            return self.p[i]\n\n    def isSameSet(self, i, j):\n        return self.findSet(i) == self.findSet(j)\n\n    def unionSet(self, i, j):\n        if (not self.isSameSet(i, j)):\n            self.numSets -= 1\n            x = self.findSet(i)\n            y = self.findSet(j)\n        # rank is used to keep the tree short\n        if (self.rank[x] > self.rank[y]):\n            self.p[y] = x\n            self.setSize[x] += self.setSize[y]\n        else:\n            self.p[x] = y\n            self.setSize[y] += self.setSize[x]\n            if (self.rank[x] == self.rank[y]):\n                self.rank[y] += 1\n\n    def numDisjointSets(self):\n        return self.numSets\n\n    def sizeOfSet(self, i):\n        return self.setSize[self.findSet(i)]\n\ndef main():\n    # Graph in Figure 4.10 left, format: list of weighted edges\n    # This example shows another form of reading graph input\n    # 5 7\n    # 0 1 4\n    # 0 2 4\n    # 0 3 6\n    # 0 4 6\n    # 1 2 2\n    # 2 3 8\n    # 3 4 9\n\n    f = open(\"mst_in.txt\", \"r\")\n\n    V, E = map(int, f.readline().split(\" \"))\n    # Kruskal's algorithm\n    EL = []\n    for i in range(E):\n        u, v, w = map(int, f.readline().split(\" \")) # read as (u, v, w)\n        EL.append((w, u, v))                        # reorder as (w, u, v)\n    EL.sort()                                       # sort by w, O(E log E)\n\n    mst_cost = 0\n    num_taken = 0\n    UF = UnionFind(V)                               # all V are disjoint sets\n\n    for i in range(E):                              # for each edge, O(E)\n        if num_taken == V-1:\n            break\n        w, u, v = EL[i]\n        if (not UF.isSameSet(u, v)):                # check\n            num_taken += 1                          # 1 more edge is taken\n            mst_cost += w                           # add w of this edge\n            UF.unionSet(u, v)                       # link them\n            # note: the runtime cost of UFDS is very light\n\n    # note: the number of disjoint sets must eventually be 1 for a valid MST\n    print(\"MST cost = {} (Kruskal's)\".format(mst_cost))\n\nmain()\n"
            ],
            [
                "Prim (MST)",
                "#SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/mst/prim.py\nfrom heapq import heappush, heappop\n\ndef process(u, taken, AL, pq):                      # set u as taken and enqueue neighbors of u\n    taken[u] = 1\n    for v, w in AL[u]:\n        if (not taken[v]):\n            heappush(pq, (w, v))                    # sort by (inc) weight\n                                                    # then by (inc) id\n\ndef main():\n    # Graph in Figure 4.10 left, format: list of weighted edges\n    # This example shows another form of reading graph input\n    # 5 7\n    # 0 1 4\n    # 0 2 4\n    # 0 3 6\n    # 0 4 6\n    # 1 2 2\n    # 2 3 8\n    # 3 4 9\n\n    f = open(\"mst_in.txt\", \"r\")\n\n    V, E = map(int, f.readline().split(\" \"))\n    # Prim's algorithm\n    AL = [[] for i in range(V)]                     # the graph stored in AL\n    for i in range(E):\n        u, v, w = map(int, f.readline().split(\" \")) # read as (u, v, w)\n        AL[u].append((v, w))\n        AL[v].append((u, w))\n\n    taken = [0 for i in range(V)]                   # to avoid cycle, no vertex is taken\n    pq = []                                         # to select shorter edges\n    process(0, taken, AL, pq)                       # take+process vertex 0\n    mst_cost = 0                                    # no edge has been taken\n    num_taken = 0\n    while len(pq) > 0 and num_taken < V-1:          # until we take V-1 edges\n        w, u = heappop(pq)\n        if not taken[u]:                            # we have not taken u yet\n            num_taken += 1                          # 1 more edge is taken\n            mst_cost += w                           # add w of this edge\n            process(u, taken, AL, pq)               # take+process vertex u\n                                                    # each edge is in pq once\n\n    print(\"MST cost = {} (Prim's)\".format(mst_cost))\n\nmain()\n"
            ],
            [
                "Bellman Ford (SSSP)",
                "#SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/sssp/bellman_ford.py\ndef main():\n    INF = int(1e9)\n\n    # Graph in Figure 4.18, has negative weight, but no negative cycle\n    # 5 5 0\n    # 0 1 1\n    # 0 2 10\n    # 1 3 2\n    # 2 3 -10\n    # 3 4 3\n\n    # Graph in Figure 4.19, negative cycle exists, Bellman Ford's can detect this\n    # 3 3 0\n    # 0 1 1000\n    # 1 2 15\n    # 2 1 -42\n\n    f = open(\"bellman_ford_in.txt\", \"r\")\n\n    V, E, s = map(int, f.readline().split(\" \"))\n    AL = [[] for u in range(V)]\n    for _ in range(E):\n        u, v, w = map(int, f.readline().split(\" \"))\n        AL[u].append((v, w))\n\n    # Bellman Ford's routine, basically = relax all E edges V-1 times\n    dist = [INF for u in range(V)]               # INF = 1e9 here\n    dist[s] = 0\n    for i in range(0, V-1):                      # total O(V*E)\n        modified = False                         # optimization\n        for u in range(0, V):                    # these two loops = O(E)\n            if (not dist[u] == INF):             # important check\n                for v, w in AL[u]:\n                    if (dist[u]+w >= dist[v]): continue # not improving, skip\n                    dist[v] = dist[u]+w          # relax operation\n                    modified = True              # optimization\n        if (not modified): break                 # optimization\n\n    hasNegativeCycle = False\n    for u in range(0, V):                        # one more pass to check\n        if (not dist[u] == INF):\n            for v, w in AL[u]:\n                if (dist[v] > dist[u] + w):      # should be false\n                    hasNegativeCycle = True      # if true => -ve cycle\n    print(\"Negative Cycle Exist? {}\".format(\"Yes\" if hasNegativeCycle else \"No\"))\n\n    if (not hasNegativeCycle):\n        for u in range(0, V):\n            print(\"SSSP({}, {}) = {}\".format(s, u, dist[u]))\n\nmain()\n"
            ],
            [
                "Dijkstra (SSSP)",
                "#SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/sssp/dijkstra.py\nfrom heapq import heappush, heappop\n\ndef main():\n    INF = int(1e9)\n\n    # Graph in Figure 4.17\n    # 5 7 0\n    # 0 1 2\n    # 0 2 6\n    # 0 3 7\n    # 1 3 3\n    # 1 4 6\n    # 2 4 1\n    # 3 4 5\n\n    f = open(\"dijkstra_in.txt\", \"r\")\n\n    V, E, s = map(int, f.readline().split(\" \"))\n    AL = [[] for u in range(V)]\n    for _ in range(E):\n        u, v, w = map(int, f.readline().split(\" \"))\n        AL[u].append((v, w))                     # directed graph\n\n    # (Modified) Dijkstra's routine\n    dist = [INF for u in range(V)]\n    dist[s] = 0\n    pq = []\n    heappush(pq, (0, s))\n\n    # sort the pairs by non-decreasing distance from s\n    while (len(pq) > 0):                    # main loop\n        d, u = heappop(pq)                  # shortest unvisited u\n        if (d > dist[u]): continue          # a very important check\n        for v, w in AL[u]:                  # all edges from u\n            if (dist[u]+w >= dist[v]): continue # not improving, skip\n            dist[v] = dist[u]+w             # relax operation\n            heappush(pq, (dist[v], v))  \n\n    for u in range(V):\n        print(\"SSSP({}, {}) = {}\".format(s, u, dist[u]))\n\nmain()\n"
            ],
            [
                "BFS (SSSP)",
                "#SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/sssp/bfs.py\nfrom collections import deque\n\np = []\n\ndef printPath(u):\n    if p[u] == -1:\n        print(\"{}\".format(u), end=\"\")\n        return\n    printPath(p[u])\n    print(\" {}\".format(u), end=\"\")\n\ndef main():\n    INF = int(1e9)\n\n    # Graph in Figure 4.3, format: list of unweighted edges\n    # This example shows another form of reading graph input\n    # 13 16\n    # 0 1    1 2    2  3   0  4   1  5   2  6    3  7   5  6\n    # 4 8    8 9    5 10   6 11   7 12   9 10   10 11  11 12\n\n    f = open(\"bfs_in.txt\", \"r\")\n\n    V, E = map(int, f.readline().split())\n    AL = [[] for u in range(V)]\n    for _ in range(E):\n        token = f.readline().split()\n        for i in range(0, len(token), 2):\n            AL[int(token[i])].append((int(token[i+1]), 0))\n            AL[int(token[i+1])].append((int(token[i]), 0))\n\n    # as an example, we start from this source, see Figure 4.3\n    s = 5\n\n    # BFS routine inside main() -- we do not use recursion\n    dist = [INF for u in range(V)]\n    dist[s] = 0\n    q = deque()\n    q.append(s)\n    global p\n    p = [-1 for u in range(V)]              # p is global\n\n    layer = -1                              # for output printing\n    isBipartite = True                      # additional feature\n\n    while (len(q) > 0):\n        u = q.popleft()\n        if (dist[u] != layer): print(\"\\nLayer {}: \".format(dist[u]), end = \"\")\n        layer = dist[u]\n        print(\"visit {}, \".format(u), end = \"\")\n        for v, w in AL[u]:                  # w ignored\n            if dist[v] == INF:\n                dist[v] = dist[u]+1         # dist[v] != INF now\n                p[v] = u                    # parent of v is u\n                q.append(v)                 # for next iteration\n            elif dist[v]%2 == dist[u]%2:    # same parity\n                isBipartite = False\n\n    print(\"\\nShortest path: \", end = \"\")\n    printPath(7)\n    print(\"\\nisBipartite? {}\".format(isBipartite))\n\nmain()\n"
            ],
            [
                "Toposort",
                "#SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/traversal/toposort.py\nimport sys\nfrom enum import Enum\n\nclass flag(Enum):\n  UNVISITED = -1\n  VISITED = -2\n\nAL = []\ndfs_num = []\nts = []\n\ndef toposort(u):\n  global AL\n  global dfs_num\n  global ts\n\n  dfs_num[u] = flag.VISITED.value\n  for v, w in AL[u]:\n    if dfs_num[v] == flag.UNVISITED.value:\n      toposort(v)\n  ts.append(u)\n\n\ndef main():\n  global AL\n  global dfs_num\n  global ts\n\n  fp = open('toposort_in.txt', 'r')\n\n  V = int(fp.readline().strip())\n  AL = [[] for _ in range(V)]\n  for u in range(V):\n    tkn = list(map(int, fp.readline().strip().split()))\n    k = tkn[0]\n    for i in range(k):\n      v, w = tkn[2*i+1], tkn[2*i+2]\n      AL[u].append((v, w))\n\n  print('Topological Sort (the input graph must be DAG)')\n  dfs_num = [flag.UNVISITED.value] * V\n  for u in range(V):\n    if dfs_num[u] == flag.UNVISITED.value:\n      toposort(u)\n  ts = ts[::-1]\n  print(' '.join(map(str, ts)))\n\n\nmain()\n"
            ],
            [
                "Trie",
                "#SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch6/Trie.py\nclass vertex:\n  def __init__(self, chr: str):\n    self.alphabet = chr\n    self.exist = False\n    self.child = [None] * 26\n\nclass Trie:\n  def __init__(self):\n    self.root = vertex('!')\n\n  def insert(self, word):\n    cur = self.root\n    for w in word:\n      alphaNum = ord(w)-ord('A')\n      if cur.child[alphaNum] == None:\n        cur.child[alphaNum] = vertex(w)\n      cur = cur.child[alphaNum]\n    cur.exist = True\n\n  def search(self, word):\n    cur = self.root\n    for w in word:\n      alphaNum = ord(w)-ord('A')\n      if cur.child[alphaNum] == None:\n        return False\n      cur = cur.child[alphaNum]\n    return cur.exist\n\n  def startsWith(self, prefix):\n    cur = self.root\n    for w in prefix:\n      alphaNum = ord(w)-ord('A')\n      if cur.child[alphaNum] == None:\n        return False\n      cur = cur.child[alphaNum]\n    return True\n\n\ndef main():\n  T = Trie()\n  S = ['CAR', 'CAT', 'RAT']\n  for s in S:\n    print('Insert', s)\n    T.insert(s)\n\n  print('\\'CAR\\' exist?', T.search(\"CAR\"))\n  print('\\'DOG\\' exist?', T.search(\"DOG\"))\n  print('Starts with \\'CA\\' exist?', T.startsWith(\"CA\"))\n  print('Starts with \\'Z\\' exist?', T.startsWith(\"Z\"))\n  print('Starts with \\'AT\\' exist?', T.startsWith(\"AT\"))\n\n\nmain()\n"
            ],
            [
                "Max flow / Min Cut",
                "#SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch8/maxflow.py\n\"\"\"\nCourtesy of Steven Halim, Felix Halim, Suhendry Effendy\nCP4 Free Source Code Project (cpp/gnu++17, java/java11, py/python3, and ml/ocaml).\nhttps://github.com/stevenhalim/cpbook-code/blob/master/ch8/maxflow.py\n\"\"\"\nfrom numbers import Number\nfrom copy import deepcopy\n\nINF = float('inf')\n\n\nclass MaxFlow:\n    def __init__(self, V: int):\n        \"\"\"\n        Creates a new instance of the MaxFlow class. The general way you'll\n        want to use this library is to create a new instance of the class,\n        add edges, then call the `edmonds_karp` or `dinic` methods.\n        While the library does support floats, be aware that it is not advised\n        to use due to the potential for floating point errors, meaning small\n        amounts of flow may be sent many times.\n\n        Arguments:\n            V: The number of vertices in the graph.\n\n        Example:\n            >>> mf = MaxFlow(3)\n            >>> mf.add_edge(0, 1, 3)\n            >>> mf.add_edge(0, 2, 3)\n            >>> mf.add_edge(1, 2, 3)\n            >>> mf.dinic(0, 2)  # or mf.edmonds_karp(0, 2)\n            6\n        \"\"\"\n        self.V = V\n        self.EL = []\n        self.AL = [list() for _ in range(self.V)]\n        self.d = []\n        self.last = []\n        self.p = []\n        self.has_been_run = False\n\n    def BFS(self, s: int, t: int) -> bool:\n        self.d = [-1] * self.V\n        self.d[s] = 0\n        self.p = [[-1, -1] for _ in range(self.V)]\n        q = [s]\n        while len(q) != 0:\n            u = q[0]\n            q.pop(0)\n            if u == t:\n                break\n            for idx in self.AL[u]:\n                v, cap, flow = self.EL[idx]\n                if cap - flow > 0 and self.d[v] == -1:\n                    self.d[v] = self.d[u]+1\n                    q.append(v)\n                    self.p[v] = [u, idx]\n        return self.d[t] != -1\n\n    def send_one_flow(self, s: int, t: int, f: Number = INF) -> Number:\n        if s == t:\n            return f\n        u, idx = self.p[t]\n        _, cap, flow = self.EL[idx]\n        pushed = self.send_one_flow(s, u, min(f, cap-flow))\n        flow += pushed\n        self.EL[idx][2] = flow\n        self.EL[idx ^ 1][2] -= pushed\n        return pushed\n\n    def DFS(self, u: int, t: int, f: Number = INF) -> Number:\n        if u == t or f == 0:\n            return f\n        for i in range(self.last[u], len(self.AL[u])):\n            self.last[u] = i\n            v, cap, flow = self.EL[self.AL[u][i]]\n            if self.d[v] != self.d[u]+1:\n                continue\n            pushed = self.DFS(v, t, min(f, cap - flow))\n            if pushed != 0:\n                flow += pushed\n                self.EL[self.AL[u][i]][2] = flow\n                self.EL[self.AL[u][i] ^ 1][2] -= pushed\n                return pushed\n        return 0\n\n    def add_edge(self, u: int, v: int, capacity: Number,\n                 directed: bool = True) -> None:\n        \"\"\"\n        Adds an edge from `u` to `v` with capacity `w`. By default, the edge is\n        directed, i.e. `u`->`v`. You can set `directed = False` to add it\n        as an undirected edge `u`<->`v`.\n\n        Arguments:\n            `u`: The first vertex.\n            `v`: The second vertex.\n            `capacity`: The capacity of the edge.\n            `directed`: Whether the edge is directed. True by default.\n\n        Example:\n            >>> mf = MaxFlow(3)\n            >>> mf.add_edge(0, 1, 3)\n            >>> mf.add_edge(2, 1, 3)\n        \"\"\"\n        if u == v:\n            return\n        self.EL.append([v, capacity, 0])\n        self.AL[u].append(len(self.EL)-1)\n        self.EL.append([u, 0 if directed else capacity, 0])\n        self.AL[v].append(len(self.EL)-1)\n\n    def assert_has_not_already_been_run(self):\n        if self.has_been_run:\n            msg = ('Rerunning a max flow algorithm on the same graph will '\n                   + 'result in incorrect behaviour. Please use .copy() '\n                   + 'before you run any max flow algorithm if you need to '\n                   + 'run multiple iterations')\n            raise Exception(msg)\n\n        self.has_been_run = True\n\n    def edmonds_karp(self, s: int, t: int) -> Number:\n        \"\"\"\n        Returns the max flow obtained by running Edmons-Karp algorithm.\n        Modifies the graph in place.\n\n        Arguments:\n            `s`: The source vertex.\n            `t`: The sink vertex.\n\n        Returns:\n            The max flow.\n        \"\"\"\n        self.assert_has_not_already_been_run()\n\n        mf = 0\n        while self.BFS(s, t):\n            f = self.send_one_flow(s, t)\n            if f == 0:\n                break\n            mf += f\n        return mf\n\n    def dinic(self, s: int, t: int) -> Number:\n        \"\"\"\n        Returns the max flow obtained by running Dinic's algorithm.\n        Modifies the graph in place.\n\n        Arguments:\n            `s`: The source vertex.\n            `t`: The sink vertex.\n\n        Returns:\n            The max flow.\n        \"\"\"\n        self.assert_has_not_already_been_run()\n\n        mf = 0\n        while self.BFS(s, t):\n            self.last = [0] * self.V\n            f = self.DFS(s, t)\n            while f != 0:\n                mf += f\n                f = self.DFS(s, t)\n        return mf\n\n    def copy(self) -> 'MaxFlow':\n        \"\"\"\n        Returns a deep copy of the current instance. This is convenient for\n        problems where you need to run MaxFlow multiple times on slightly\n        different graphs, since the instance is destroyed after each max flow\n        run.\n\n        Example:\n            >>> mf = MaxFlow(4)\n            >>> mf.add_edge(0, 1, 3)\n            >>> mf.add_edge(1, 2, 3)\n            >>> for c in range(1, 4):\n            >>>     mf_copy = mf.copy()\n            >>>     mf_copy.add_edge(2, 3, c)\n            >>>     res = mf_copy.dinic(0, 3)  # Will not modify mf\n        \"\"\"\n        return deepcopy(self)\n\n    def __repr__(self) -> str:\n        el = self.EL[:10] + ['...'] if len(self.EL) > 10 else self.EL\n        al = self.AL[:10] + ['...'] if len(self.AL) > 10 else self.AL\n        el = ', '.join(map(str, el))\n        al = ', '.join(map(str, al))\n        return f'MaxFlow(V={self.V}, EL=[{el}], AL=[{al}])'\n\n\ndef main():\n    fp = open('maxflow_in.txt', 'r')\n    V, s, t = map(int, fp.readline().strip().split())\n    mf = MaxFlow(V)\n\n    for u in range(V):\n        tkn = list(map(int, fp.readline().strip().split()))\n        k = tkn[0]\n        for i in range(k):\n            v, w = tkn[2*i+1], tkn[2*i+2]\n            mf.add_edge(u, v, w)\n\n    # print(mf.edmonds_karp(s, t))\n    print(mf.dinic(s, t))\n\n\nif __name__ == '__main__':\n    main()\n"
            ],
            [
                "Min Cost Max Flow",
                "#SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch9/mcmf.py\nINF = 10**18\n\nclass min_cost_max_flow:\n  def __init__(self, V):\n    self.V = V\n    self.EL = []\n    self.AL = [list() for _ in range(V)]\n    self.vis = [False] * V\n    self.total_cost = 0\n    self.d = None\n    self.last = None\n\n  def SPFA(self, s, t):\n    self.d = [INF] * self.V\n    self.d[s] = 0\n    self.vis[s] = True\n    q = [s]\n    while len(q) != 0:\n      u = q[0]\n      q.pop(0)\n      self.vis[u] = False\n      for idx in self.AL[u]:\n        v, cap, flow, cost = self.EL[idx]\n        if cap-flow > 0 and self.d[v] > self.d[u]+cost:\n          self.d[v] = self.d[u]+cost\n          if not self.vis[v]:\n            q.append(v)\n            self.vis[v] = True\n    return self.d[t] != INF\n\n  def DFS(self, u, t, f=INF):\n    if u == t or f == 0:\n      return f\n    self.vis[u] = True\n    for i in range(self.last[u], len(self.AL[u])):\n      v, cap, flow, cost = self.EL[self.AL[u][i]]\n      if not self.vis[v] and self.d[v] == self.d[u]+cost:\n        pushed = self.DFS(v, t, min(f, cap-flow))\n        if pushed != 0:\n          self.total_cost += pushed * cost\n          flow += pushed\n          self.EL[self.AL[u][i]][2] = flow\n          rv, rcap, rflow, rcost = self.EL[self.AL[u][i]^1]\n          rflow -= pushed\n          self.EL[self.AL[u][i]^1][2] = rflow\n          self.vis[u] = False\n          self.last[u] = i\n          return pushed\n    self.vis[u] = False\n    return 0\n\n  def add_edge(self, u, v, w, c, directed=True):\n    if u == v:\n      return\n    self.EL.append([v, w, 0, c])\n    self.AL[u].append(len(self.EL)-1)\n    self.EL.append([u, 0 if directed else w, 0, -c])\n    self.AL[v].append(len(self.EL)-1)\n\n  def mcmf(self, s, t):\n    mf = 0\n    while self.SPFA(s, t):\n      self.last = [0] * self.V\n      f = self.DFS(s, t)\n      while f != 0:\n        mf += f\n        f = self.DFS(s, t)\n    return mf, self.total_cost\n\n\ndef main():\n  V, E, s, t = map(int, input().split())\n  mf = min_cost_max_flow(V)\n  for _ in range(E):\n    u, v, w, c = map(int, input().split())\n    mf.add_edge(u, v, w, c)\n  res = mf.mcmf(s, t)\n  print('%d %d' % (res[0], res[1]))\n\n\nmain()\n"
            ]
        ]
    },
    "java": {
        "repr": "Java",
        "default": "public class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello world!\");\n    }\n}\n",
        "template": [
            [
                "AVL Tree",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch2/nonlineards/AVL.java\nimport java.util.*;\nimport java.util.NoSuchElementException; // we will use this to illustrate Java Error Handling mechanism\n\n// Every vertex in this BST is a Java Class\nclass BSTVertex {\n  BSTVertex(int v) { key = v; parent = left = right = null; height = 0; }\n  // all these attributes remain public to slightly simplify the code\n  public BSTVertex parent, left, right;\n  public int key;\n  public int height; // will be used in AVL lecture\n}\n\n// This is just a sample implementation\n// There are other ways to implement BST concepts...\nclass BST {\n  protected BSTVertex root;\n\n  protected BSTVertex search(BSTVertex T, int v) {\n         if (T == null)  return T;                                  // not found\n    else if (T.key == v) return T;                                      // found\n    else if (T.key < v)  return search(T.right, v);       // search to the right\n    else                 return search(T.left, v);         // search to the left\n  }\n\n  protected BSTVertex insert(BSTVertex T, int v) {\n    if (T == null) return new BSTVertex(v);          // insertion point is found\n\n    if (T.key < v) {                                      // search to the right\n      T.right = insert(T.right, v);\n      T.right.parent = T;\n    }\n    else {                                                 // search to the left\n      T.left = insert(T.left, v);\n      T.left.parent = T;\n    }\n\n    return T;                                          // return the updated BST\n  }\n\n  protected void inorder(BSTVertex T) {\n    if (T == null) return;\n    inorder(T.left);                               // recursively go to the left\n    System.out.printf(\" %d\", T.key);                      // visit this BST node\n    inorder(T.right);                             // recursively go to the right\n  }\n\n  // Example of Java error handling mechanism\n  /* // old code, returns -1 when there is no minimum (the BST is empty)\n  protected int findMin(BSTVertex T) {\n         if (T == null)      return -1;                             // not found\n    else if (T.left == null) return T.key;                    // this is the min\n    else                     return findMin(T.left);           // go to the left\n  }\n  */\n\n  protected int findMin(BSTVertex T) {\n         if (T == null)      throw new NoSuchElementException(\"BST is empty, no minimum\");\n    else if (T.left == null) return T.key;                    // this is the min\n    else                     return findMin(T.left);           // go to the left\n  }\n\n  protected int findMax(BSTVertex T) {\n         if (T == null)       throw new NoSuchElementException(\"BST is empty, no maximum\");\n    else if (T.right == null) return T.key;                   // this is the max\n    else                      return findMax(T.right);        // go to the right\n  }\n\n  protected int successor(BSTVertex T) {\n    if (T.right != null)                       // this subtree has right subtree\n      return findMin(T.right);  // the successor is the minimum of right subtree\n    else {\n      BSTVertex par = T.parent;\n      BSTVertex cur = T;\n      // if par(ent) is not root and cur(rent) is its right children\n      while ((par != null) && (cur == par.right)) {\n        cur = par;                                         // continue moving up\n        par = cur.parent;\n      }\n      return par == null ? -1 : par.key;           // this is the successor of T\n    }\n  }\n\n  protected int predecessor(BSTVertex T) {\n    if (T.left != null)                         // this subtree has left subtree\n      return findMax(T.left);  // the predecessor is the maximum of left subtree\n    else {\n      BSTVertex par = T.parent;\n      BSTVertex cur = T;\n      // if par(ent) is not root and cur(rent) is its left children\n      while ((par != null) && (cur == par.left)) { \n        cur = par;                                         // continue moving up\n        par = cur.parent;\n      }\n      return par == null ? -1 : par.key;           // this is the successor of T\n    }\n  }\n\n  protected BSTVertex delete(BSTVertex T, int v) {\n    if (T == null)  return T;              // cannot find the item to be deleted\n\n    if (T.key == v) {                          // this is the node to be deleted\n      if (T.left == null && T.right == null)                   // this is a leaf\n        T = null;                                      // simply erase this node\n      else if (T.left == null && T.right != null) {   // only one child at right\n        T.right.parent = T.parent;             // ma, take care of my only child\n        T = T.right;                                                 // bypass T\n      }\n      else if (T.left != null && T.right == null) {    // only one child at left\n        T.left.parent = T.parent;              // ma, take care of my only child\n        T = T.left;                                                  // bypass T\n      }\n      else {                // has two children, find successor to avoid quarrel\n        int successorV = successor(v);             // predecessor is also OK btw\n        T.key = successorV;         // replace this key with the successor's key\n        T.right = delete(T.right, successorV);      // delete the old successorV\n      }\n    }\n    else if (T.key < v)                                   // search to the right\n      T.right = delete(T.right, v);\n    else                                                   // search to the left\n      T.left = delete(T.left, v);\n    return T;                                          // return the updated BST\n  }\n\n  public BST() { root = null; }\n\n  public int search(int v) {\n    BSTVertex res = search(root, v);\n    return res == null ? -1 : res.key;\n  }\n\n  public void insert(int v) { root = insert(root, v); }\n\n  public void inorder() { \n    inorder(root);\n    System.out.println();\n  }\n\n  public int findMin() { return findMin(root); }\n\n  public int findMax() { return findMax(root); }\n\n  public int successor(int v) { \n    BSTVertex vPos = search(root, v);\n    return vPos == null ? -1 : successor(vPos);\n  }\n\n  public int predecessor(int v) { \n    BSTVertex vPos = search(root, v);\n    return vPos == null ? -1 : predecessor(vPos);\n  }\n\n  public void delete(int v) { root = delete(root, v); }\n\n  // will be used in AVL lecture\n  protected int getHeight(BSTVertex T) {\n    if (T == null) return -1;\n    else return Math.max(getHeight(T.left), getHeight(T.right)) + 1;\n  }\n\n  public int getHeight() { return getHeight(root); }\n}\n\nclass AVL extends BST { // an example of Java inheritance\n  public AVL() { root = null; }\n\n  private int h(BSTVertex T) { return T == null ? -1 : T.height; }\n\n  protected BSTVertex rotateLeft(BSTVertex T) {\n    // T must have a right child\n\n    BSTVertex w = T.right;\n    w.parent = T.parent;\n    T.parent = w;\n    T.right = w.left;\n    if (w.left != null) w.left.parent = T;\n    w.left = T;\n\n    T.height = Math.max(h(T.left), h(T.right)) + 1;\n    w.height = Math.max(h(w.left), h(w.right)) + 1;\n\n    return w;\n  }\n\n  protected BSTVertex rotateRight(BSTVertex T) {\n    // T must have a left child\n\n    BSTVertex w = T.left;\n    w.parent = T.parent;\n    T.parent = w;\n    T.left = w.right;\n    if (w.right != null) w.right.parent = T;\n    w.right = T;\n\n    T.height = Math.max(h(T.left), h(T.right)) + 1;\n    w.height = Math.max(h(w.left), h(w.right)) + 1;\n\n    return w;\n  }\n\n  protected BSTVertex insert(BSTVertex T, int v) {\n    if (T == null) return new BSTVertex(v);          // insertion point is found\n\n    if (T.key < v) {                                      // search to the right\n      T.right = insert(T.right, v);\n      T.right.parent = T;\n    }\n    else {                                                 // search to the left\n      T.left = insert(T.left, v);\n      T.left.parent = T;\n    }\n\n    int balance = h(T.left) - h(T.right);\n    if (balance == 2) { // left heavy\n      int balance2 = h(T.left.left) - h(T.left.right);\n      if (balance2 == 1) {\n        T = rotateRight(T);\n      }\n      else { // -1\n        T.left = rotateLeft(T.left);\n        T = rotateRight(T);\n      }\n    }\n    else if (balance == -2) { // right heavy\n      int balance2 = h(T.right.left) - h(T.right.right);\n      if (balance2 == -1)\n        T = rotateLeft(T);\n      else { // 1\n        T.right = rotateRight(T.right);\n        T = rotateLeft(T);\n      }\n    }\n\n    T.height = Math.max(h(T.left), h(T.right)) + 1;\n    return T;                                          // return the updated AVL\n  }\n\n  protected BSTVertex delete(BSTVertex T, int v) {\n    if (T == null)  return T;              // cannot find the item to be deleted\n\n    if (T.key == v) {                          // this is the node to be deleted\n      if (T.left == null && T.right == null)                   // this is a leaf\n        T = null;                                      // simply erase this node\n      else if (T.left == null && T.right != null) {   // only one child at right\n        BSTVertex temp = T;\n        T.right.parent = T.parent;\n        T = T.right;                                                 // bypass T\n        temp = null;\n      }\n      else if (T.left != null && T.right == null) {    // only one child at left\n        BSTVertex temp = T;\n        T.left.parent = T.parent;\n        T = T.left;                                                  // bypass T\n        temp = null;\n      }\n      else {                                 // has two children, find successor\n        int successorV = successor(v);\n        T.key = successorV;         // replace this key with the successor's key\n        T.right = delete(T.right, successorV);      // delete the old successorV\n      }\n    }\n    else if (T.key < v)                                   // search to the right\n      T.right = delete(T.right, v);\n    else                                                   // search to the left\n      T.left = delete(T.left, v);\n\n    if (T != null) {               // similar as insertion code except this line\n      int balance = h(T.left) - h(T.right);\n      if (balance == 2) { // left heavy\n        int balance2 = h(T.left.left) - h(T.left.right);\n        if (balance2 == 1) {\n          T = rotateRight(T);\n        }\n        else { // -1\n          T.left = rotateLeft(T.left);\n          T = rotateRight(T);\n        }\n      }\n      else if (balance == -2) { // right heavy\n        int balance2 = h(T.right.left) - h(T.right.right);\n        if (balance2 == -1)\n          T = rotateLeft(T);\n        else { // 1\n          T.right = rotateRight(T.right);\n          T = rotateLeft(T);\n        }\n      }\n\n      T.height = Math.max(h(T.left), h(T.right)) + 1;\n    }\n\n    return T;                                          // return the updated BST\n  }\n}\n\nclass AVL {\n  public static void main(String[] args) throws Exception {\n    // let's contrast and compare\n    BST T = new BST();                                           // an empty BST\n    AVL A = new AVL();                                           // an empty AVL\n\n    int n = 12;\n    int[] arr = new int[]{15, 32, 100, 6, 23, 4, 7, 71, 5, 50, 3, 1};\n    for (int i = 0; i < n; i++) {\n      T.insert(arr[i]);\n      A.insert(arr[i]);\n    }\n\n    // Example of Java polymorphism: method getHeight() returns different value\n    System.out.println(T.getHeight());                         // 4, taller tree\n    System.out.println(A.getHeight());                        // 3, shorter tree\n\n    // Another Java polymorphism: method inorder() returns similar value\n    T.inorder();                      // The BST: 1 3 4 5 6 7 15 23 32 50 71 100\n    A.inorder();                      // The AVL: 1 3 4 5 6 7 15 23 32 50 71 100\n\n    System.out.println(\"---\");\n    System.out.println(A.search(71));                               // found, 71\n    System.out.println(A.search(7));                                 // found, 7\n    System.out.println(A.search(22));                           // not found, -1\n\n    System.out.println(A.findMin());                                        // 1\n    System.out.println(A.findMax());                                      // 100\n\n    System.out.println(\"---\");\n    System.out.println(A.successor(1));                                     // 3\n    System.out.println(A.successor(3));                                     // 4\n    System.out.println(A.successor(4));                                     // 5\n    System.out.println(A.successor(5));                                     // 6\n    System.out.println(A.successor(6));                                     // 7\n    System.out.println(A.successor(7));                                    // 15\n    System.out.println(A.successor(15));                                   // 23\n    System.out.println(A.successor(23));                                   // 32\n    System.out.println(A.successor(32));                                   // 50\n    System.out.println(A.successor(50));                                   // 71\n    System.out.println(A.successor(71));                                  // 100\n    System.out.println(A.successor(100));                                  // -1\n\n    System.out.println(\"---\");\n    System.out.println(A.predecessor(1));                                  // -1\n    System.out.println(A.predecessor(3));                                   // 1\n    System.out.println(A.predecessor(4));                                   // 3\n    System.out.println(A.predecessor(5));                                   // 4\n    System.out.println(A.predecessor(6));                                   // 5\n    System.out.println(A.predecessor(7));                                   // 6\n    System.out.println(A.predecessor(15));                                  // 7\n    System.out.println(A.predecessor(23));                                 // 15\n    System.out.println(A.predecessor(32));                                 // 23\n    System.out.println(A.predecessor(50));                                 // 32\n    System.out.println(A.predecessor(71));                                 // 50\n    System.out.println(A.predecessor(100));                                // 71\n\n    // deletion demo\n    System.out.println(\"---\");\n    System.out.print(\"Current BST/AVL:\");\n    A.inorder();\n\n    int[] deletionorder = new int[]{23, 100, 32, 71, 50, 7, 5, 1, 3, 6, 15, 4};\n    for (int i = 0; i < n; i++) {\n      System.out.println(\"Deleting: \" + deletionorder[i]);\n\n      A.delete(deletionorder[i]);\n      System.out.print(\"AVL, height: \" + A.getHeight() + \", inorder traversal: \");\n      A.inorder();\n\n      T.delete(deletionorder[i]);\n      System.out.print(\"BST, height: \" + T.getHeight() + \", inorder traversal: \"); // equal or taller than A.getHeight()\n      T.inorder(); // should be the same as A.inorder()\n    }\n  }\n}\n"
            ],
            [
                "Quick Select",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch2/nonlineards/QuickSelect.java\nimport java.util.*;\n\nclass QuickSelect {\n  static int Partition(int A[], int l, int r) {\n    int p = A[l];                                // p is the pivot\n    int m = l;                                   // S1 and S2 are empty\n    int temp;\n    for (int k = l+1; k <= r; ++k) {             // explore unknown region\n      if (A[k] < p) {                            // case 2\n        m++;\n        temp = A[k]; A[k] = A[m]; A[m] = temp;\n      } // notice that we do nothing in case 1: a[k] >= p\n    }\n    temp = A[l]; A[l] = A[m]; A[m] = temp;       // swap pivot with a[m]\n    return m;                                    // return pivot index\n  }\n\n  static int RandPartition(int[] A, int l, int r) {\n    Random rnd = new Random();\n    int p = l + rnd.nextInt(r-l+1);              // select a random pivot\n    int temp = A[l]; A[l] = A[p]; A[p] = temp;   // swap A[p] with A[l]\n    return Partition(A, l, r);\n  }\n\n  static int QuickSelect(int[] A, int l, int r, int k) {\n    if (l == r) return A[l];\n    int q = RandPartition(A, l, r);\n    if (q+1 == k)\n      return A[q];\n    else if (q+1 > k)\n      return QuickSelect(A, l, q-1, k);\n    else\n      return QuickSelect(A, q+1, r, k);\n  }\n\n  public static void main(String[] args) {\n    int[] A = new int[] { 2, 8, 7, 1, 5, 4, 6, 3 }; // permutation of [1..8]\n\n    System.out.println(QuickSelect(A, 0, 7, 8)); // the output must be 8\n    System.out.println(QuickSelect(A, 0, 7, 7)); // the output must be 7\n    System.out.println(QuickSelect(A, 0, 7, 6)); // the output must be 6\n    System.out.println(QuickSelect(A, 0, 7, 5)); // the output must be 5\n    System.out.println(QuickSelect(A, 0, 7, 4)); // the output must be 4\n    System.out.println(QuickSelect(A, 0, 7, 3)); // the output must be 3\n    System.out.println(QuickSelect(A, 0, 7, 2)); // the output must be 2\n    System.out.println(QuickSelect(A, 0, 7, 1)); // the output must be 1\n\n    // try experimenting with the content of array A to see the behavior of \"QuickSelect\"\n  }\n}\n"
            ],
            [
                "Fenwick Tree",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch2/ourown/fenwicktree_ds.java\nimport java.util.*;\n\nclass FenwickTree {\n  private ArrayList<Integer> ft;\n\n  private int LSOne(int S) { return (S & (-S)); }\n\n  public FenwickTree() {}\n\n  // initialization: n + 1 zeroes, ignore index 0\n  public FenwickTree(int n) { \n    ft = new ArrayList<>();\n    for (int i = 0; i <= n; i++) ft.add(0);\n  }\n\n  public int rsq(int j) {                              // returns RSQ(1, j)\n    int sum = 0; for (; j > 0; j -= LSOne(j)) sum += ft.get(j);\n    return sum; }\n\n  public int rsq(int i, int j) {                       // returns RSQ(i, j)\n    return rsq(j) - rsq(i-1); }\n\n  // updates value of the i-th element by v (v can be +ve/inc or -ve/dec)\n  void update(int i, int v) {                      // note: n = ft.size()-1\n    for (; i < (int)ft.size(); i += LSOne(i)) ft.set(i, ft.get(i)+v); }\n};\n\nclass fenwicktree_ds {\n  public static void main(String[] args) {\n                                          // idx   0 1 2 3 4 5 6 7  8 9 10, no index 0!\n    FenwickTree ft = new FenwickTree(10); // ft = {-,0,0,0,0,0,0,0, 0,0,0}\n    ft.update(2, 1);                      // ft = {-,0,1,0,1,0,0,0, 1,0,0}, idx 2,4,8 => +1\n    ft.update(4, 1);                      // ft = {-,0,1,0,2,0,0,0, 2,0,0}, idx 4,8 => +1\n    ft.update(5, 2);                      // ft = {-,0,1,0,2,2,2,0, 4,0,0}, idx 5,6,8 => +2\n    ft.update(6, 3);                      // ft = {-,0,1,0,2,2,5,0, 7,0,0}, idx 6,8 => +3\n    ft.update(7, 2);                      // ft = {-,0,1,0,2,2,5,2, 9,0,0}, idx 7,8 => +2\n    ft.update(8, 1);                      // ft = {-,0,1,0,2,2,5,2,10,0,0}, idx 8 => +1\n    ft.update(9, 1);                      // ft = {-,0,1,0,2,2,5,2,10,1,1}, idx 9,10 => +1\n    System.out.printf(\"%d\\n\", ft.rsq(1, 1));  // 0 => ft[1] = 0\n    System.out.printf(\"%d\\n\", ft.rsq(1, 2));  // 1 => ft[2] = 1\n    System.out.printf(\"%d\\n\", ft.rsq(1, 6));  // 7 => ft[6] + ft[4] = 5 + 2 = 7\n    System.out.printf(\"%d\\n\", ft.rsq(1, 10)); // 11 => ft[10] + ft[8] = 1 + 10 = 11\n    System.out.printf(\"%d\\n\", ft.rsq(3, 6));  // 6 => rsq(1, 6) - rsq(1, 2) = 7 - 1\n\n    ft.update(5, 2); // update demo\n    System.out.printf(\"%d\\n\", ft.rsq(1, 10)); // now 13\n  }\n}\n"
            ],
            [
                "Segment Tree",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch2/ourown/segmenttree_ds.java\nimport java.util.*;\n\nclass SegmentTree {         // the segment tree is stored like a heap array\n  private int[] st, A;\n  private int n;\n  private int left (int p) { return p << 1; } // same as binary heap operations\n  private int right(int p) { return (p << 1) + 1; }\n\n  private void build(int p, int L, int R) {\n    if (L == R)                            // as L == R, either one is fine\n      st[p] = L;                                         // store the index\n    else {                                // recursively compute the values\n      build(left(p) , L              , (L + R) / 2);\n      build(right(p), (L + R) / 2 + 1, R          );\n      int p1 = st[left(p)], p2 = st[right(p)];\n      st[p] = (A[p1] <= A[p2]) ? p1 : p2;\n  } }\n\n  private int rmq(int p, int L, int R, int i, int j) {          // O(log n)\n    if (i >  R || j <  L) return -1; // current segment outside query range\n    if (L >= i && R <= j) return st[p];               // inside query range\n\n     // compute the min position in the left and right part of the interval\n    int p1 = rmq(left(p) , L              , (L+R) / 2, i, j);\n    int p2 = rmq(right(p), (L+R) / 2 + 1, R          , i, j);\n\n    if (p1 == -1) return p2;   // if we try to access segment outside query\n    if (p2 == -1) return p1;                               // same as above\n    return (A[p1] <= A[p2]) ? p1 : p2; }          // as as in build routine\n\n  private int update_point(int p, int L, int R, int idx, int new_value) {\n    // this update code is still preliminary, i == j\n    // must be able to update range in the future!\n    int i = idx, j = idx;\n\n    // if the current interval does not intersect \n    // the update interval, return this st node value!\n    if (i > R || j < L)\n      return st[p];\n\n    // if the current interval is included in the update range,\n    // update that st[node]\n    if (L == i && R == j) {\n      A[i] = new_value; // update the underlying array\n      return st[p] = L; // this index\n    }\n\n    // compute the minimum position in the \n    // left and right part of the interval\n    int p1, p2;\n    p1 = update_point(left(p) , L              , (L + R) / 2, idx, new_value);\n    p2 = update_point(right(p), (L + R) / 2 + 1, R          , idx, new_value);\n\n    // return the position where the overall minimum is\n    return st[p] = (A[p1] <= A[p2]) ? p1 : p2;\n  }\n\n  public SegmentTree(int[] _A) {\n    A = _A; n = A.length;                   // copy content for local usage\n    st = new int[4 * n];\n    for (int i = 0; i < 4 * n; i++) st[i] = 0; // create vector with length `len' and fill it with zeroes\n    build(1, 0, n - 1);                                  // recursive build\n  }\n\n  public int rmq(int i, int j) { return rmq(1, 0, n - 1, i, j); } // overloading\n\n  public int update_point(int idx, int new_value) {\n    return update_point(1, 0, n - 1, idx, new_value); }\n}\n\nclass segmenttree_ds {\n  public static void main(String[] args) {\n    int[] A = new int[] { 18, 17, 13, 19, 15, 11, 20 }; // the original array\n    SegmentTree st = new SegmentTree(A);\n\n    System.out.printf(\"              idx    0, 1, 2, 3, 4,  5, 6\\n\");\n    System.out.printf(\"              A is {18,17,13,19,15, 11,20}\\n\");\n    System.out.printf(\"RMQ(1, 3) = %d\\n\", st.rmq(1, 3)); // answer = index 2\n    System.out.printf(\"RMQ(4, 6) = %d\\n\", st.rmq(4, 6)); // answer = index 5\n    System.out.printf(\"RMQ(3, 4) = %d\\n\", st.rmq(3, 4)); // answer = index 4\n    System.out.printf(\"RMQ(0, 0) = %d\\n\", st.rmq(0, 0)); // answer = index 0\n    System.out.printf(\"RMQ(0, 1) = %d\\n\", st.rmq(0, 1)); // answer = index 1\n    System.out.printf(\"RMQ(0, 6) = %d\\n\", st.rmq(0, 6)); // answer = index 5\n\n    System.out.printf(\"              idx    0, 1, 2, 3, 4,  5, 6\\n\");\n    System.out.printf(\"Now, modify A into {18,17,13,19,15,100,20}\\n\");\n    st.update_point(5, 100);                  // update A[5] from 11 to 100\n    System.out.printf(\"These values do not change\\n\");\n    System.out.printf(\"RMQ(1, 3) = %d\\n\", st.rmq(1, 3));               // 2\n    System.out.printf(\"RMQ(3, 4) = %d\\n\", st.rmq(3, 4));               // 4\n    System.out.printf(\"RMQ(0, 0) = %d\\n\", st.rmq(0, 0));               // 0\n    System.out.printf(\"RMQ(0, 1) = %d\\n\", st.rmq(0, 1));               // 1\n    System.out.printf(\"These values change\\n\");\n    System.out.printf(\"RMQ(0, 6) = %d\\n\", st.rmq(0, 6));            // 5->2\n    System.out.printf(\"RMQ(4, 6) = %d\\n\", st.rmq(4, 6));            // 5->4\n    System.out.printf(\"RMQ(4, 5) = %d\\n\", st.rmq(4, 5));            // 5->4\n  }\n}\n"
            ],
            [
                "Union Find",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch2/ourown/unionfind_ds.java\nimport java.util.*;\n\n// Union-Find Disjoint Sets Library written in OOP manner, using both path compression and union by rank heuristics\nclass UnionFind {                                              // OOP style\n  private ArrayList<Integer> p, rank, setSize;\n  private int numSets;\n\n  public UnionFind(int N) {\n    p = new ArrayList<>(N);\n    rank = new ArrayList<>(N);\n    setSize = new ArrayList<>(N);\n    numSets = N;\n    for (int i = 0; i < N; i++) {\n      p.add(i);\n      rank.add(0);\n      setSize.add(1);\n    }\n  }\n\n  public int findSet(int i) { \n    if (p.get(i) == i) return i;\n    else {\n      int ret = findSet(p.get(i)); p.set(i, ret);\n      return ret; } }\n\n  public Boolean isSameSet(int i, int j) { return findSet(i) == findSet(j); }\n\n  public void unionSet(int i, int j) { \n    if (!isSameSet(i, j)) { numSets--; \n    int x = findSet(i), y = findSet(j);\n    // rank is used to keep the tree short\n    if (rank.get(x) > rank.get(y)) { p.set(y, x); setSize.set(x, setSize.get(x) + setSize.get(y)); }\n    else                           { p.set(x, y); setSize.set(y, setSize.get(y) + setSize.get(x));\n                                     if (rank.get(x) == rank.get(y)) rank.set(y, rank.get(y) + 1); } } }\n  public int numDisjointSets() { return numSets; }\n  public int sizeOfSet(int i) { return setSize.get(findSet(i)); }\n}\n\nclass unionfind_ds {\n  public static void main(String[] args) {\n    System.out.printf(\"Assume that there are 5 disjoint sets initially\\n\");\n    UnionFind UF = new UnionFind(5); // create 5 disjoint sets\n    System.out.printf(\"%d\\n\", UF.numDisjointSets()); // 5\n    UF.unionSet(0, 1);\n    System.out.printf(\"%d\\n\", UF.numDisjointSets()); // 4\n    UF.unionSet(2, 3);\n    System.out.printf(\"%d\\n\", UF.numDisjointSets()); // 3\n    UF.unionSet(4, 3);\n    System.out.printf(\"%d\\n\", UF.numDisjointSets()); // 2\n    System.out.printf(\"isSameSet(0, 3) = %b\\n\", UF.isSameSet(0, 3)); // will return false\n    System.out.printf(\"isSameSet(4, 3) = %b\\n\", UF.isSameSet(4, 3)); // will return true\n    for (int i = 0; i < 5; i++) // findSet will return 1 for {0, 1} and 3 for {2, 3, 4}\n      System.out.printf(\"findSet(%d) = %d, sizeOfSet(%d) = %d\\n\", i, UF.findSet(i), i, UF.sizeOfSet(i));\n    UF.unionSet(0, 3);\n    System.out.printf(\"%d\\n\", UF.numDisjointSets()); // 1\n    for (int i = 0; i < 5; i++) // findSet will return 3 for {0, 1, 2, 3, 4}\n      System.out.printf(\"findSet(%d) = %d, sizeOfSet(%d) = %d\\n\", i, UF.findSet(i), i, UF.sizeOfSet(i));\n  }\n}\n"
            ],
            [
                "Floyd Warshall (APAP)",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/floyd_warshall.java\nimport java.util.*;\nimport java.io.*;\n\npublic class floyd_warshall {\n  public static void main(String[] args) throws Exception {\n    /*\n    // Graph in Figure 4.20\n    5 9\n    0 1 2\n    0 2 1\n    0 4 3\n    1 3 4\n    2 1 1\n    2 4 1\n    3 0 1\n    3 2 3\n    3 4 5\n    */\n\n    Scanner sc = new Scanner(new File(\"floyd_warshall_in.txt\"));\n    int V = sc.nextInt(), E = sc.nextInt();\n    \n    int[][] AM = new int[V][];\n    for (int u = 0; u < V; ++u) {\n      AM[u] = new int[V];\n      for (int v = 0; v < V; ++v)\n        AM[u][v] = 1000000000;                   // 1e9 to avoid overflow\n      AM[u][u] = 0;\n    }\n\n    for (int i = 0; i < E; ++i) {\n      int u = sc.nextInt(), v = sc.nextInt(), w = sc.nextInt();\n      AM[u][v] = w;                              // directed graph\n    }\n\n    for (int k = 0; k < V; ++k)                  // O(v^3) Floyd Warshall's\n      for (int u = 0; u < V; ++u)\n        for (int v = 0; v < V; ++v)\n          AM[u][v] = Math.min(AM[u][v], AM[u][k]+AM[k][v]);\n\n    for (int u = 0; u < V; ++u)\n      for (int v = 0; v < V; ++v)\n        System.out.printf(\"APSP(%d, %d) = %d\\n\", u, v, AM[u][v]);\n  }\n}\n"
            ],
            [
                "MCBM",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/mcbm.java\nimport java.util.*;\nimport java.text.*;\n\nclass mcbm {\n  private static ArrayList<ArrayList<Integer>> AL = new ArrayList<>();\n  private static ArrayList<Integer> match, visited; // global variables\n\n  private static int Aug(int l) {\n    if (visited.get(l) == 1) return 0;\n    visited.set(l, 1);\n\n    Iterator it = AL.get(l).iterator();\n    while (it.hasNext()) { // either greedy assignment or recurse\n      Integer right = (Integer)it.next();\n      if (match.get(right) == -1 || Aug(match.get(right)) == 1) {\n        match.set(right, l);\n        return 1; // we found one matching\n      }\n    }\n\n    return 0; // no matching\n  }\n\n  private static Boolean isprime(int v) {\n    int primes[] = new int[] {2,3,5,7,11,13,17,19,23,29};\n    for (int i = 0; i < 10; i++)\n      if (primes[i] == v)\n        return true;\n    return false;\n  }\n\n  public static void main(String[] args) {\n/*\n    // Graph in Figure 4.40 can be built on the fly\n    // we know there are 6 vertices in this bipartite graph, l side are numbered 0,1,2, right side 3,4,5\n    //int V = 6, V_l = 3;\n    //int set1[] = new int[] {1,7,11}, set2[] = new int[] {4,10,12};\n\n    // Graph in Figure 4.41 can be built on the fly\n    // we know there are 5 vertices in this bipartite graph, l side are numbered 0,1, right side 3,4,5\n    int V = 5, V_l = 2;\n    int set1[] = new int[] {1,7}, set2[] = new int[] {4,10,12};\n\n    // build the bipartite graph, only directed edge from l to right is needed\n    AL.clear();\n    for (i = 0; i < V; i++) {\n      ArrayList<Integer> Neighbor = new ArrayList<Integer>();\n      AL.add(Neighbor); // store blank ArrayList first\n    }\n    \n    for (i = 0; i < V_l; i++)\n      for (j = 0; j < 3; j++)\n        if (isprime(set1[i] + set2[j]))\n          AL.get(i).add(3 + j);\n*/\n\n    // For bipartite graph in Figure 4.44, V = 5, Vleft = 3 (vertex 0 unused)\n    // AL[0] = {} // dummy vertex, but you can choose to use this vertex\n    // AL[1] = {3, 4}\n    // AL[2] = {3}\n    // AL[3] = {}   // we use directed edges from left to right set only\n    // AL[4] = {}\n\n    int V = 5, V_l = 3;\n    AL.clear();\n    for (int i = 0; i < V; i++) {\n      ArrayList<Integer> Neighbor = new ArrayList<Integer>();\n      AL.add(Neighbor); // store blank ArrayList first\n    }\n    AL.get(1).add(3);\n    AL.get(1).add(4);\n    AL.get(2).add(3);\n\n    int MCBM = 0;\n    match = new ArrayList < Integer > ();\n    match.addAll(Collections.nCopies(V, -1));\n    for (int l = 0; l < V_l; l++) {\n      visited = new ArrayList < Integer > ();\n      visited.addAll(Collections.nCopies(V_l, 0));\n      MCBM += Aug(l);\n    }\n    System.out.printf(\"Found %d matchings\\n\", MCBM);\n  }\n}\n"
            ],
            [
                "Hierholzer",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/hierholzer.java\nimport java.util.*;\nimport java.text.*;\n\nclass hierholzer {\n  private static int N;\n  private static ArrayList<ArrayList<Integer>> AL; // Directed graph\n\n  private static ArrayList<Integer> hierholzer(int s) {\n    ArrayList<Integer> ans = new ArrayList<>();\n    ArrayList<Integer> idx = new ArrayList<>(Collections.nCopies(N, 0));\n    ArrayList<Integer> st = new ArrayList<>();\n    st.add(s);\n    while (!st.isEmpty()) {\n      int u = st.get(st.size()-1);\n      if (idx.get(u) < AL.get(u).size()) {       // still has neighbor\n        st.add(AL.get(u).get(idx.get(u)));\n        idx.set(u, idx.get(u)+1);\n      }\n      else {\n        ans.add(u);\n        st.remove(st.size()-1);\n      }\n    }\n    Collections.reverse(ans);\n    return ans;\n  }\n\n  public static void main(String[] args) {\n    // The directed graph shown in Figure 4.40\n    N = 7;\n    AL = new ArrayList<>(N);\n    for (int i = 0; i < N; ++i)\n      AL.add(new ArrayList<>());\n    AL.get(0).add(1); AL.get(0).add(6); // A->[B,G]\n    AL.get(1).add(2); // B->C\n    AL.get(2).add(3); AL.get(2).add(4); // C->[D,E]\n    AL.get(3).add(0); // D->A\n    AL.get(4).add(5); // E->F\n    AL.get(5).add(0); AL.get(5).add(2); // F->[A,C]\n    AL.get(6).add(5); // G->F\n    ArrayList<Integer> ans = hierholzer(0);\n    for (Integer u : ans)\n      System.out.print((char)('A'+u) + \" \");\n    System.out.println();\n  }\n}\n"
            ],
            [
                "Kruskal (MST)",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/mst/kruskal.java\nimport java.util.*;\nimport java.io.*;\n\n// Union-Find Disjoint Sets Library written in OOP manner, using both path compression and union by rank heuristics\nclass UnionFind {                                              // OOP style\n  private ArrayList<Integer> p, rank, setSize;\n  private int numSets;\n\n  public UnionFind(int N) {\n    p = new ArrayList<Integer>(N);\n    rank = new ArrayList<Integer>(N);\n    setSize = new ArrayList<Integer>(N);\n    numSets = N;\n    for (int i = 0; i < N; i++) {\n      p.add(i);\n      rank.add(0);\n      setSize.add(1);\n    }\n  }\n\n  public int findSet(int i) { \n    if (p.get(i) == i) return i;\n    else {\n      int ret = findSet(p.get(i)); p.set(i, ret);\n      return ret;\n    }\n  }\n\n  public Boolean isSameSet(int i, int j) { return findSet(i) == findSet(j); }\n\n  public void unionSet(int i, int j) { \n    if (!isSameSet(i, j)) { numSets--; \n    int x = findSet(i), y = findSet(j);\n    // rank is used to keep the tree short\n    if (rank.get(x) > rank.get(y)) { p.set(y, x); setSize.set(x, setSize.get(x) + setSize.get(y)); }\n    else                           { p.set(x, y); setSize.set(y, setSize.get(y) + setSize.get(x));\n                                     if (rank.get(x) == rank.get(y)) rank.set(y, rank.get(y) + 1); } } }\n  public int numDisjointSets() { return numSets; }\n  public int sizeOfSet(int i) { return setSize.get(findSet(i)); }\n}\n\npublic class kruskal {\n  public static void main(String[] args) throws Exception {\n    /*\n    // Graph in Figure 4.10 left, format: list of weighted edges\n    // This example shows another form of reading graph input\n    5 7\n    0 1 4\n    0 2 4\n    0 3 6\n    0 4 6\n    1 2 2\n    2 3 8\n    3 4 9\n    */\n\n    File f = new File(\"mst_in.txt\");\n    Scanner sc = new Scanner(f);\n\n    // Kruskal's algorithm\n    int V = sc.nextInt(), E = sc.nextInt();\n    ArrayList<IntegerTriple> EL = new ArrayList<>();\n    for (int i = 0; i < E; ++i) {\n      int u = sc.nextInt(), v = sc.nextInt(), w = sc.nextInt();\n      EL.add(new IntegerTriple(w, u, v));        // reorder as (w, u, v)\n    }\n    Collections.sort(EL);                        // sort by w, O(E log E)\n\n    int mst_cost = 0, num_taken = 0;             // no edge has been taken\n    UnionFind UF = new UnionFind(V);             // all V are disjoint sets\n    for (int i = 0; i < E; ++i) {                // up to O(E)\n      IntegerTriple front = EL.get(i);\n      if (UF.isSameSet(front.second(), front.third())) continue; // check\n      mst_cost += front.first();                 // add w of this edge\n      UF.unionSet(front.second(), front.third());// link them\n      ++num_taken;                               // 1 more edge is taken\n      if (num_taken == V-1) break;               // optimization\n    }\n\n    // note: the number of disjoint sets must eventually be 1 for a valid MST\n    System.out.printf(\"MST cost = %d (Kruskal's)\\n\", mst_cost);\n  }\n}\n"
            ],
            [
                "Prim (MST)",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/mst/prim.java\nimport java.util.*;\nimport java.io.*;\n\npublic class prim {\n  static ArrayList<ArrayList<IntegerPair>> AL = new ArrayList<>();\n  static ArrayList<Boolean> taken = new ArrayList<>(); // global boolean flag to avoid cycle\n  static PriorityQueue<IntegerPair> pq = new PriorityQueue<>(); // priority queue to help choose shorter edges\n\n  static void process(int u) { //  we do not need to use -ve sign to reverse the sort order\n    taken.set(u, true);\n    for (IntegerPair v_w : AL.get(u))\n      if (!taken.get(v_w.first()))\n        pq.offer(new IntegerPair(v_w.second(), v_w.first()));\n  }\n\n  public static void main(String[] args) throws Exception {\n    /*\n    // Graph in Figure 4.10 left, format: list of weighted edges\n    // This example shows another form of reading graph input\n    5 7\n    0 1 4\n    0 2 4\n    0 3 6\n    0 4 6\n    1 2 2\n    2 3 8\n    3 4 9\n    */\n\n    File f = new File(\"mst_in.txt\");\n    Scanner sc = new Scanner(f);\n\n// inside int main() --- assume the graph is stored in AL, pq is empty\n    int V = sc.nextInt(), E = sc.nextInt();\n    AL.clear();\n    for (int i = 0; i < V; ++i) {\n      ArrayList<IntegerPair> Neighbor = new ArrayList<>();\n      AL.add(Neighbor);                          // a blank ArrayList\n    }\n  \n    // sort by edge weight O(E log E)\n    // PQ default: sort descending. Trick: use <(negative) weight(i, j), <i, j> >\n    for (int i = 0; i < E; ++i) {\n      int u = sc.nextInt(), v = sc.nextInt(), w = sc.nextInt();\n      AL.get(u).add(new IntegerPair(v, w));\n      AL.get(v).add(new IntegerPair(u, w));\n    }\n\n    int mst_cost = 0, num_taken = 0;             // no edge has been taken\n    for (int i = 0; i < V; ++i)\n      taken.add(false);                          // no vertex has been taken\n    process(0);                                  // take & process vertex 0\n    while (!pq.isEmpty()) {                      // up to O(E)\n      IntegerPair front = pq.peek(); pq.poll();\n      int u = front.second(), w = front.first(); // no need to negate id/weight\n      if (taken.get(u)) continue;                // already taken, skipped\n      mst_cost += w;                             // add w of this edge\n      process(u);                                // take+process vertex u\n      ++num_taken;                               // 1 more edge is taken\n      if (num_taken == V-1) break;               // optimization\n    }\n    System.out.printf(\"MST cost = %d (Prim's)\\n\", mst_cost);\n  }\n}\n"
            ],
            [
                "Bellman Ford (SSSP)",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/sssp/bellman_ford.java\nimport java.util.*;\nimport java.io.*;\n\npublic class bellman_ford {\n  public static final int INF = 1000000000;\n\t  \n  public static void main(String[] args) throws Exception {\n    /*\n    // Graph in Figure 4.18, has negative weight, but no negative cycle\n    5 5 0\n    0 1 1\n    0 2 10\n    1 3 2\n    2 3 -10\n    3 4 3\n\n    // Graph in Figure 4.19, negative cycle exists\n    3 3 0\n    0 1 1000\n    1 2 15\n    2 1 -42\n    */\n\n    Scanner sc = new Scanner(new File(\"bellman_ford_in.txt\"));\n\n    int V = sc.nextInt(), E = sc.nextInt(), s = sc.nextInt();\n    ArrayList<ArrayList<IntegerPair>> AL = new ArrayList<>();\n    for (int u = 0; u < V; ++u) {\n      ArrayList<IntegerPair> Neighbor = new ArrayList<>();\n      AL.add(Neighbor);\n    }\n    while (E-- > 0) {\n      int u = sc.nextInt(), v = sc.nextInt(), w = sc.nextInt();\n      AL.get(u).add(new IntegerPair(v, w));\n    }\n    \n  // Bellman Ford's routine, basically = relax all E edges V-1 times\n    ArrayList<Integer> dist = new ArrayList<>(Collections.nCopies(V, INF)); dist.set(s, 0); // INF = 1e9 here\n    for (int i = 0; i < V-1; ++i) {              // total O(V*E)\n      Boolean modified = false;                  // optimization\n      for (int u = 0; u < V; ++u)                // these two loops = O(E)\n        if (dist.get(u) != INF)                  // important check\n          for (IntegerPair v_w : AL.get(u)) {\n            int v = v_w.first(), w = v_w.second();\n            if (dist.get(u)+w >= dist.get(v)) continue; // not improving, skip\n            dist.set(v, dist.get(u)+w);          // relax operation\n            modified = true;                     // optimization\n          }\n      if (!modified) break;\n    }\n\n    Boolean hasNegativeCycle = false;\n    for (int u = 0; u < V; ++u)                  // one more pass to check\n      if (dist.get(u) != INF)\n        for (IntegerPair v_w: AL.get(u)) {\n          int v = v_w.first(), w = v_w.second();\n          if (dist.get(v) > dist.get(u)+w)       // should be false\n          hasNegativeCycle = true;               // if true => -ve cycle\n        }\n    System.out.printf(\"Negative Cycle Exist? %s\\n\", hasNegativeCycle ? \"Yes\" : \"No\");\n\n    if (!hasNegativeCycle)\n      for (int u = 0; u < V; ++u)\n        System.out.printf(\"SSSP(%d, %d) = %d\\n\", s, u, dist.get(u));\n  }\n}\n"
            ],
            [
                "Dijkstra (SSSP)",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/sssp/dijkstra.java\nimport java.util.*;\nimport java.io.*;\n\npublic class dijkstra {\n  public static final int INF = 1000000000;\n  \n  public static void main(String[] args) throws Exception {\n    /*\n    // Graph in Figure 4.17\n    5 7 2\n    2 1 2\n    2 3 7\n    2 0 6\n    1 3 3\n    1 4 6\n    3 4 5\n    0 4 1\n    */\n\n    Scanner sc = new Scanner(new File(\"dijkstra_in.txt\"));\n\n    int V = sc.nextInt(), E = sc.nextInt(), s = sc.nextInt();\n    ArrayList<ArrayList<IntegerPair>> AL = new ArrayList<>();\n    for (int u = 0; u < V; ++u) {\n      ArrayList<IntegerPair> Neighbor = new ArrayList<>();\n      AL.add(Neighbor);\n    }\n    while (E-- > 0) {\n      int u = sc.nextInt(), v = sc.nextInt(), w = sc.nextInt();\n      AL.get(u).add(new IntegerPair(v, w));\n    }\n\n    ArrayList<Integer> dist = new ArrayList<>(Collections.nCopies(V, INF)); dist.set(s, 0); // INF = 1e9 here\n\n    // Original Dijkstra's algorithm\n    /*\n    TreeSet<IntegerPair> pq = new TreeSet<>();   // balanced BST version\n    for (int u = 0; u < V; ++u)                  // dist[u] = INF\n      pq.add(new IntegerPair(dist.get(u), u));   // but dist[s] = 0\n\n    // sort the pairs by non-decreasing distance from s\n    while (!pq.isEmpty()) {                      // main loop\n      IntegerPair top = pq.pollFirst();\n      int u = top.second();                      // shortest unvisited u\n      for (IntegerPair v_w : AL.get(u)) {        // all edges from u\n        int v = v_w.first(), w = v_w.second();\n        if (dist.get(u)+w >= dist.get(v)) continue; // not improving, skip\n        pq.remove(new IntegerPair(dist.get(v), v)); // erase old pair\n        dist.set(v, dist.get(u)+w);              // relax operation\n        pq.add(new IntegerPair(dist.get(v), v)); // enqueue better pair\n      }\n    }\n    */\n\n    // (Modified) Dijkstra's algorithm\n    PriorityQueue<IntegerPair> pq = new PriorityQueue<>(); pq.offer(new IntegerPair(0, s));\n\n    // sort the pairs by non-decreasing distance from s\n    while (!pq.isEmpty()) {                      // main loop\n      IntegerPair top = pq.poll();\n      int d = top.first(), u = top.second();     // shortest unvisited u\n      if (d > dist.get(u)) continue;             // a very important check\n      for (IntegerPair v_w : AL.get(u)) {        // all edges from u\n        int v = v_w.first(), w = v_w.second();\n        if (dist.get(u)+w >= dist.get(v)) continue; // not improving, skip\n        dist.set(v, dist.get(u)+w);              // relax operation\n        pq.offer(new IntegerPair(dist.get(v), v)); // enqueue better pair\n      }\n    }\n  \n    for (int u = 0; u < V; ++u)\n      System.out.printf(\"SSSP(%d, %d) = %d\\n\", s, u, dist.get(u));\n  }\n}\n"
            ],
            [
                "BFS (SSSP)",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/sssp/bfs.java\nimport java.util.*;\nimport java.io.*;\n\npublic class bfs {\n  private static final int INF = 1000000000;\n\n  private static ArrayList<Integer> p = new ArrayList<>();\n\n  private static void printPath(int u) {\n    if (p.get(u) == -1) { System.out.printf(\"%d\", u); return; }\n    printPath(p.get(u));\n    System.out.printf(\" %d\", u);\n  }\n  \n  public static void main(String[] args) throws Exception {\n    /*\n    // Graph in Figure 4.3, format: list of unweighted edges\n    // This example shows another form of reading graph input\n    13 16\n    0 1    1 2    2  3   0  4   1  5   2  6    3  7   5  6\n    4 8    8 9    5 10   6 11   7 12   9 10   10 11  11 12\n    */\n\n    Scanner sc = new Scanner(new File(\"bfs_in.txt\"));\n\n    int V = sc.nextInt(), E = sc.nextInt();\n    ArrayList<ArrayList<IntegerPair>> AL = new ArrayList<>();\n    for (int u = 0; u < V; ++u) {\n      ArrayList<IntegerPair> Neighbor = new ArrayList<>();\n      AL.add(Neighbor);\n    }\n    while (E-- > 0) {\n      int a = sc.nextInt(), b = sc.nextInt();\n      AL.get(a).add(new IntegerPair(b, 0));\n      AL.get(b).add(new IntegerPair(a, 0));\n    }\n\n    // as an example, we start from this source, see Figure 4.3\n    int s = 5;\n\n    // BFS routine inside void main(String[] args) -- we do not use recursion\n    ArrayList<Integer> dist = new ArrayList<>(Collections.nCopies(V, INF)); dist.set(s, 0); // INF = 1e9 here\n    Queue<Integer> q = new LinkedList<>(); q.offer(s);\n    p.clear(); p.addAll(Collections.nCopies(V, -1)); // p is global\n\n    int layer = -1;                              // for output printing\n    Boolean isBipartite = true;                  // additional feature\n\n    while (!q.isEmpty()) {\n      int u = q.poll();\n      if (dist.get(u) != layer) System.out.printf(\"\\nLayer %d: \", dist.get(u));\n      layer = dist.get(u);\n      System.out.printf(\"visit %d, \", u);\n      for (IntegerPair v_w : AL.get(u)) {\n        int v = v_w.first();                     // w ignored\n        if (dist.get(v) == INF) {\n          dist.set(v, dist.get(u)+1);            // dist[v] != INF now\n          p.set(v, u);                           // parent of v is u\n          q.offer(v);                            // for next iteration\n        }\n        else if ((dist.get(v)%2) == (dist.get(u)%2)) // same parity\n          isBipartite = false;\n      }\n    }\n\n    System.out.printf(\"\\nShortest path: \");\n    printPath(7); System.out.printf(\"\\n\");\n    System.out.printf(\"isBipartite? %d\\n\", isBipartite ? 1 : 0);\n  }\n}\n"
            ],
            [
                "Toposort",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch4/traversal/toposort.java\nimport java.util.*;\nimport java.io.*;\n\npublic class toposort {\n  private static final int UNVISITED = 0;        // we only need these two\n  private static final int VISITED = 1;\n\n  // these variables have to be global to be easily accessible by our recursion (other ways exist)\n  private static ArrayList<ArrayList<IntegerPair>> AL;\n  private static ArrayList<Integer> dfs_num;\n  private static ArrayList<Integer> ts;\n\n  private static void toposort(int u) {\n    dfs_num.set(u, VISITED);\n    for (IntegerPair v_w : AL.get(u))\n      if (dfs_num.get(v_w.first()) == UNVISITED)\n        toposort(v_w.first());\n    ts.add(u);                                   // this is the only change\n  }\n\n  public static void main(String[] args) throws Exception {\n    /*\n    // Example of a Directed Acyclic Graph in Figure 4.4 (for toposort)\n    8\n    2 1 0 2 0\n    2 2 0 3 0\n    2 3 0 5 0\n    1 4 0\n    0\n    0\n    0\n    1 6 0\n    */\n\n    Scanner sc = new Scanner(new File(\"toposort_in.txt\"));\n\n    int V = sc.nextInt();\n    AL = new ArrayList<>();\n    for (int u = 0; u < V; ++u) {\n      AL.add(new ArrayList<>());                 // store blank vector first\n      int k = sc.nextInt();\n      while (k-- > 0) {\n        int v = sc.nextInt(), w = sc.nextInt();\n        AL.get(u).add(new IntegerPair(v, w));\n      }\n    }\n\n    // make sure that the given graph is DAG\n    System.out.printf(\"Topological Sort (the input graph must be DAG)\\n\");\n    dfs_num = new ArrayList<>(Collections.nCopies(V, UNVISITED)); // global variable\n    ts = new ArrayList<>();                      // global variable\n    for (int u = 0; u < V; ++u)\n      if (dfs_num.get(u) == UNVISITED)\n        toposort(u);\n    // reverse ts or simply read the content of ts backwards\n    for (int i = ts.size()-1; i >= 0; --i)\n      System.out.printf(\" %d\", ts.get(i));\n    System.out.printf(\"\\n\");\n  }\n}\n"
            ],
            [
                "Trie",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch6/Trie.java\nimport java.util.*;\n\nclass vertex {\n  public char alphabet;\n  public Boolean exist;\n  public ArrayList<vertex> child;\n\n  public vertex(char a) {\n    alphabet = a;\n    exist = false;\n    child = new ArrayList<>(Collections.nCopies(26, null));\n  }\n};\n\nclass Trie {                                     // this is TRIE\n  private vertex root;                           // NOT Suffix Trie\n\n  public Trie() { root = new vertex('!'); }\n\n  public void insert(String word) {              // insert a word into trie\n    vertex cur = root;\n    for (int i = 0; i < word.length(); ++i) {    // O(n)\n      int alphaNum = word.charAt(i)-'A';\n      if (cur.child.get(alphaNum) == null)       // add new branch if null\n        cur.child.set(alphaNum, new vertex(word.charAt(i)));\n      cur = cur.child.get(alphaNum);\n    }\n    cur.exist = true;\n  }\n\n  public Boolean search(String word) {           // true if word in trie\n    vertex cur = root;\n    for (int i = 0; i < word.length(); ++i) {    // O(m)\n      int alphaNum = word.charAt(i)-'A';\n      if (cur.child.get(alphaNum) == null)       // not found\n        return false;\n      cur = cur.child.get(alphaNum);\n    }\n    return cur.exist;                            // check exist flag\n  }\n\n  public Boolean startsWith(String prefix) {     // true if match prefix\n    vertex cur = root;\n    for (int i = 0; i < prefix.length(); ++i) {\n      int alphaNum = prefix.charAt(i)-'A';\n      if (cur.child.get(alphaNum) == null)       // not found\n        return false;\n      cur = cur.child.get(alphaNum);\n    }\n    return true;                                 // reach here, return true\n  }\n\n  public static void main(String[] args) {\n    Trie T = new Trie();\n    TreeSet<String> S = new TreeSet<>() {{ add(\"CAR\"); add(\"CAT\"); add(\"RAT\"); }};\n    for (String str : S) {\n      System.out.printf(\"Insert %s\\n\", str);\n      T.insert(str);\n    }\n    System.out.printf(\"'CAR' exist? %d\\n\", T.search(\"CAR\") ? 1 : 0); // 1 (true)\n    System.out.printf(\"'DOG' exist? %d\\n\", T.search(\"DOG\") ? 1 : 0); // 0 (false)\n    System.out.printf(\"Starts with 'CA' exist? %d\\n\", T.startsWith(\"CA\") ? 1 : 0); // 1 (true)\n    System.out.printf(\"Starts with 'Z' exist? %d\\n\", T.startsWith(\"Z\") ? 1 : 0); // 0 (false)\n    System.out.printf(\"Starts with 'AT' exist? %d\\n\", T.startsWith(\"AT\") ? 1 : 0); // 0 (false) for this Trie, but in a Suffix Trie, we have a suffix \"AT\" (from \"CAT\" or \"RAT\") that starts with \"AT\"\n  }\n};\n"
            ],
            [
                "Max flow / Min Cut",
                "//SOURCE: https://raw.githubusercontent.com/stevenhalim/cpbook-code/master/ch8/maxflow.java\nimport java.io.*;\nimport java.util.*;\n\n// (Nearly) 1-1 translation of maxflow.cpp with min-cut augmentation\nclass Pair {\n    int first, second;\n\n    Pair(int first, int second) {\n        this.first = first;\n        this.second = second;\n    }\n}\n\nclass Edge {\n    int v;\n    long w, f;\n\n    Edge(int v, long w, long f) {\n        this.v = v;\n        this.w = w;\n        this.f = f;\n    }\n}\n\npublic class maxflow {\n    static long INF = 1000000000000000000l;\n\n    int V;\n    Edge[] EL;\n    int ELSize;\n    List<List<Integer>> AL;\n    int[] d, last;\n    Pair[] p;\n\n    maxflow(int initialV, int numEdges) {\n        V = initialV;\n        EL = new Edge[2 * numEdges]; // 2 * to account for back edges\n        ELSize = 0;\n        AL = new ArrayList<>();\n        for (int i = 0; i < V; i++) {\n            AL.add(new ArrayList<>());\n        }\n    }\n\n    void addEdge(int u, int v, long w, boolean directed) {\n        if (u == v) return;                     // safeguard: no self loop\n        EL[ELSize] = new Edge(v, w, 0);         // u->v, cap w, flow 0\n        ELSize++;\n        AL.get(u).add(ELSize - 1);              // remember this index\n        EL[ELSize] = new Edge(u, directed ? 0 : w, 0);         // back edge\n        ELSize++;\n        AL.get(v).add(ELSize - 1);           // remember this index\n    }\n\n    long edmondsKarp(int s, int t) {\n        long mf = 0;                            // mf stands for max_flow\n        while (BFS(s, t)) {                     // an O(V*E^2) algorithm\n            long f = sendOneFlow(s, t, INF);         // find and send 1 flow f\n            if (f == 0) break;                  // if f == 0, stop\n            mf += f;                            // if f > 0, add to mf\n        }\n        return mf;\n    }\n\n    long dinic(int s, int t) {\n        long mf = 0;                            // mf stands for max_flow\n        while (BFS(s, t)) {                     // an O(V^2*E) algorithm\n            last = new int[V];                  // important speedup\n            long f;\n            while ((f = DFS(s, t, INF)) > 0) {   // exhaust blocking flow\n                mf += f;\n            }\n        }\n        return mf;\n    }\n\n    boolean BFS(int s, int t) {                 // find augmenting path\n        d = new int[V];\n        p = new Pair[V];                        // record BFS sp tree\n        for (int i = 0; i < V; i++) {\n            d[i] = -1;\n            p[i] = new Pair(-1, -1);\n        }\n        d[s] = 0;\n        Queue<Integer> q = new LinkedList<>();\n        q.offer(s);\n        while (!q.isEmpty()) {\n            int u = q.poll();\n            if (u == t) break;                  // stop as sink t reached\n            for (int idx : AL.get(u)) {         // explore neighbors of u\n                Edge e = EL[idx];               // stored in EL[idx]\n                int v = e.v;\n                long cap = e.w;\n                long flow = e.f;\n                if ((cap - flow > 0) && (d[v] == -1)) { // positive residual edge\n                    d[v] = d[u] + 1;\n                    q.offer(v);\n                    p[v] = new Pair(u, idx);\n                }\n            }\n        }\n        return d[t] != -1;\n    }\n\n    // Run after performing Dinics/Edmonds Karp to get nodes in min-cut\n    // Basically performs BFS on the flow graph one more time\n    List<Integer> minCut(int s, int t) {\n        List<Integer> result = new ArrayList<>();\n        d = new int[V];\n        p = new Pair[V];                        // record BFS sp tree\n        for (int i = 0; i < V; i++) {\n            d[i] = -1;\n            p[i] = new Pair(-1, -1);\n        }\n        d[s] = 0;\n        Queue<Integer> q = new LinkedList<>();\n        q.offer(s);\n        result.add(s);\n        while (!q.isEmpty()) {\n            int u = q.poll();\n            if (u == t) break;                  // stop as sink t reached\n            for (int idx : AL.get(u)) {         // explore neighbors of u\n                Edge e = EL[idx];               // stored in EL[idx]\n                int v = e.v;\n                long cap = e.w;\n                long flow = e.f;\n                if ((cap - flow > 0) && (d[v] == -1)) { // positive residual edge\n                    d[v] = d[u] + 1;\n                    q.offer(v);\n                    p[v] = new Pair(u, idx);\n                    result.add(v);\n                }\n            }\n        }\n        return result;\n    }\n\n    long sendOneFlow(int s, int t, long f) {    // send one flow from s->t\n        if (s == t) return f;                   // bottleneck edge f found\n        Pair pair = p[t];\n        int u = pair.first;\n        int idx = pair.second;\n        Edge e = EL[idx];\n        long cap = e.w;\n        long flow = e.f;\n        long pushed = sendOneFlow(s, u, Math.min(f, cap - flow));\n        e.f += pushed;\n        EL[idx ^ 1].f -= pushed;            // back flow\n        return pushed;\n    }\n\n    long DFS(int u, int t, long f) {            // traverse from s->t\n        if ((u == t) || (f == 0)) return f;\n        int start = last[u];\n        int stop = AL.get(u).size();\n        for (int i = start; i < stop; i++) {    // from last edge\n            Edge e = EL[AL.get(u).get(i)];\n            int v = e.v;\n            long cap = e.w;\n            long flow = e.f;\n            if (d[v] != d[u] + 1) continue; // not part of layer graph\n            long pushed;\n            if ((pushed = DFS(v, t, Math.min(f, cap - flow))) > 0) {\n                e.f += pushed;\n                EL[AL.get(u).get(i) ^ 1].f -= pushed;    // back flow\n                return pushed;\n            }\n        }\n        return 0;\n    }\n}\n\n"
            ]
        ]
    }
}